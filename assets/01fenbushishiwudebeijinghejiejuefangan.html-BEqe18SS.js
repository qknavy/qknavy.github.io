import{_ as l,c as p,b as i,a,d as e,e as t,r as o,o as r}from"./app-D63_8prq.js";const c={},d={href:"https://dev.mysql.com/doc/refman/8.0/en/xa.html",target:"_blank",rel:"noopener noreferrer"},m={href:"https://dev.mysql.com/doc/refman/8.0/en/xa-statements.html",target:"_blank",rel:"noopener noreferrer"},h={href:"https://www.atomikos.com",target:"_blank",rel:"noopener noreferrer"},u={href:"https://mp.weixin.qq.com/s?__biz=MzAxMjY5NDU2Ng==&mid=2651868656&idx=1&sn=d33fbb9a32d76fb461c24ab2cfda72c7&chksm=818b3e5085924b3c84aabf3f1316a50e1a0e83e026fd584c1742807e87ac1d6047c1ee17cb39&scene=27",target:"_blank",rel:"noopener noreferrer"};function b(k,n){const s=o("ExternalLinkIcon");return r(),p("div",null,[n[9]||(n[9]=i('<h2 id="_1、事务特性" tabindex="-1"><a class="header-anchor" href="#_1、事务特性"><span>1、事务特性</span></a></h2><p>我们都知道在进行业务开发的时候要考虑事务，这里的事务特性一般是指数据库操作的ACID，即原子性、一致性、隔离性和持久性。</p><ul><li>A原子性（Atomic）：整个事务作为业务完整性的最小单元，要么都执行，要么都不执行</li><li>C一致性（Consistent）：事务在完成时，必须要整数据的一致状态，事务结束时所有的内部数据结构必须是正确的。即使事务是并发多个，系统也必须保证如同串行事务一样执行，比如A给B转500块钱，A扣了500，B必须收到500，不能多也不能少</li><li>I隔离性（Isolation）：一个事务对数据的并发修改对其它事务不可见，事务之间相互隔离</li><li>D持久性（Duration）：事务完成后，对系统的影响是永久的</li></ul><p>如果是常规业务场景操作的是同一个数据源，这直接通过数据库本身的事务支持就可以很好地保证。当时如果把业务场景放到现在流行的分布式开发，比如说微服务架构下，一个业务可能调用多个服务的接口，同时会操作多个数据源，这个时候又该如何保证数据库的ACID呢？</p><p>也就是这个时候必须要依赖分布式事务解决方案了，所谓分布式事务，其本质就是要保证数据的一致性</p><h2 id="_2、分布式事务理论" tabindex="-1"><a class="header-anchor" href="#_2、分布式事务理论"><span>2、分布式事务理论</span></a></h2><h3 id="_2-1、x-opendtp-x-open-distributed-transaction-processing-reference-model" tabindex="-1"><a class="header-anchor" href="#_2-1、x-opendtp-x-open-distributed-transaction-processing-reference-model"><span>2.1、X/OpenDTP（X/Open Distributed Transaction Processing Reference Model）</span></a></h3><p>X/Open DTP是一套分布式事务模型标准，具体实现由不同的厂商去实现，它主要就是提出了二阶段提交（2pc）这个分布式事务模型，同时也定义了分布式事务中的一些参与者的角色</p><ul><li>RM：资源管理器，比如我们的数据库</li><li>TM：事务管理（协调）器</li><li>AP：应用程序</li></ul><p><img src="http://blog.shengxiao.tech/images/image-20251225083608863.png" alt="image-20251225083608863"></p><h4 id="_2-1-1、事务流程" tabindex="-1"><a class="header-anchor" href="#_2-1-1、事务流程"><span>2.1.1、事务流程</span></a></h4><p>事务流程简单描述：</p><ul><li><p>应用程序开启并注册全局事务</p></li><li><p>资源管理器分别向事务管理器注册资源</p></li><li><p>应用服务器操作资源</p></li><li><p>应用程序告知事务管理器是否要提交事务</p></li><li><p>事务管理器通知资源管理器预提交</p></li><li><p>预提交操作都正常响应之后事务管理器再通知资源管理器正式提交事务</p></li></ul><h4 id="_2-1-2、两阶段" tabindex="-1"><a class="header-anchor" href="#_2-1-2、两阶段"><span>2.1.2、两阶段</span></a></h4><p>这里两阶段主要是体现在最后的事务提交过程中</p><ul><li>第一阶段：表决。事务管理器向资源管理器发送一个提交事务的请求，资源管理器接收到这个请求后开始准备对应的事务日志，如果事务日志写成功，就会给TM一个成功的回执，否则就会返回一个失败的消息</li><li>第二阶段：提交。TM收到所有参与者的回执之后，如果所有的预提交都是成功的，则事务管理器会再发送一个提交的消息给所有的参与者，但凡有一个预提交的回执收到的是失败的结果，则TM在第二阶段会通知所有的参与者进行事务回滚。而对于所有的参与者，如果收到提交事务的消息，则会对本地事务进行提交，否则就会回滚</li></ul><h4 id="_2-1-3、两个协议" tabindex="-1"><a class="header-anchor" href="#_2-1-3、两个协议"><span>2.1.3、两个协议</span></a></h4><p>在这个过程中还涉及两个协议</p>',18)),a("ul",null,[a("li",null,[n[2]||(n[2]=a("p",null,"XA：资源管理器用来通知和协调事务的开始、提交或回滚，它是一个双向的接口，目前主流的数据库都支持XA协议",-1)),a("p",null,[a("a",d,[n[0]||(n[0]=e("https://dev.mysql.com/doc/refman/8.0/en/xa.html",-1)),t(s)])]),a("p",null,[a("a",m,[n[1]||(n[1]=e("https://dev.mysql.com/doc/refman/8.0/en/xa-statements.html",-1)),t(s)])]),n[3]||(n[3]=i(`<div class="language-sql line-numbers-mode" data-highlighter="prismjs" data-ext="sql" data-title="sql"><pre><code><span class="line">XA {<span class="token keyword">START</span><span class="token operator">|</span><span class="token keyword">BEGIN</span>} xid <span class="token punctuation">[</span><span class="token keyword">JOIN</span><span class="token operator">|</span>RESUME<span class="token punctuation">]</span> <span class="token comment">--负责开启或者恢复一个事务分支，并且管理XID到调用线程</span></span>
<span class="line">XA <span class="token keyword">END</span> xid <span class="token punctuation">[</span>SUSPEND <span class="token punctuation">[</span><span class="token keyword">FOR</span> MIGRATE<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token comment">--负责取消当前线程与事务分支的关联</span></span>
<span class="line">XA <span class="token keyword">PREPARE</span> xid <span class="token comment">--负责询问RM 是否准备好了提交事务分支</span></span>
<span class="line">XA <span class="token keyword">COMMIT</span> xid <span class="token punctuation">[</span>ONE PHASE<span class="token punctuation">]</span> <span class="token comment">--知RM提交事务分支</span></span>
<span class="line">XA <span class="token keyword">ROLLBACK</span> xid <span class="token comment">--通知RM回滚事务分支</span></span>
<span class="line">XA RECOVER <span class="token punctuation">[</span><span class="token keyword">CONVERT</span> XID<span class="token punctuation">]</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>结合上面两阶段的定义大概就是下面这个过程</p><p><img src="http://blog.shengxiao.tech/images/image-20251225093729102.png" alt="image-20251225093729102"></p>`,3))]),n[4]||(n[4]=a("li",null,[a("p",null,"TX：全局事务管理器与资源管理器之间通信的接口")],-1))]),n[10]||(n[10]=i('<h3 id="_2-2、基于xa协议的分布式事务框架" tabindex="-1"><a class="header-anchor" href="#_2-2、基于xa协议的分布式事务框架"><span>2.2、基于XA协议的分布式事务框架</span></a></h3><h4 id="_2-2-1、jta" tabindex="-1"><a class="header-anchor" href="#_2-2-1、jta"><span>2.2.1、JTA</span></a></h4><blockquote><p>Java Transaction Api，在rt.jar里边<code>javax.transaction</code>包下，具体可以自己看一下</p></blockquote><h4 id="_2-2-2、atomikos" tabindex="-1"><a class="header-anchor" href="#_2-2-2、atomikos"><span>2.2.2、Atomikos</span></a></h4>',4)),a("p",null,[n[6]||(n[6]=e("Atomikos是对JTA的实现，",-1)),a("a",h,[n[5]||(n[5]=e("官网地址",-1)),t(s)]),n[7]||(n[7]=e("，分为开源版本和商业版本，使用方法晚上很多，随便一搜一大堆，比如：",-1))]),a("p",null,[a("a",u,[n[8]||(n[8]=e("Spring Boot集成atomikos快速入门Demo",-1)),t(s)])]),n[11]||(n[11]=i(`<h4 id="_2-2-3、bitronix" tabindex="-1"><a class="header-anchor" href="#_2-2-3、bitronix"><span>2.2.3、Bitronix</span></a></h4><h4 id="_2-2-4、seata" tabindex="-1"><a class="header-anchor" href="#_2-2-4、seata"><span>2.2.4、Seata</span></a></h4><p>seata是阿里开源的一款分布式事务解决方案</p><h3 id="_2-3、基于可靠消息的最终一致性方案" tabindex="-1"><a class="header-anchor" href="#_2-3、基于可靠消息的最终一致性方案"><span>2.3、基于可靠消息的最终一致性方案</span></a></h3><p><img src="http://blog.shengxiao.tech/images/image-20251225111020809.png" alt="image-20251225111020809"></p><p>基于可靠消息的最终一致性方案大致过程如上图所示，在执行本地事务的同时，向消息中间件的broker发送一条可靠消息，然后消费者基于这个消息再去执行下游的业务，最终完成整个上下游事务的一致性。</p><p>但是这里有个问题，发送mq消息肯定不能在执行本地事务之前，因为如果在执行本地事务之前发送成功了，那么如果本地事务执行失败，mq消息没办法撤回。但是如果把发送mq消息放到执行本地事务之后呢？</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre><code><span class="line">begin transaction；</span>
<span class="line"><span class="token comment">//1.数据库操作</span></span>
<span class="line"><span class="token comment">//2.发送MQ</span></span>
<span class="line">commit transation<span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这样看似没有问题，当时想想，如果发送mq消息的时候由于网络超时导致事务回滚了，而mq消息最终还是被发送到了broker了，这时候不就又有问题了吗？</p><h4 id="_2-3-1、基于本地消息表" tabindex="-1"><a class="header-anchor" href="#_2-3-1、基于本地消息表"><span>2.3.1、基于本地消息表</span></a></h4><p>针对上面提到的问题，我们可以在本地记录一张本地消息表，将上游的事务操作改成执行业务逻辑和记录本地事务消息表，比如：</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre><code><span class="line">begin transaction；</span>
<span class="line"><span class="token comment">//1.数据库操作</span></span>
<span class="line"><span class="token comment">//2.记录消息日志表</span></span>
<span class="line">commit transation<span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这样就能保证本地事务完成的时候业务操作和记录消息日志是一个完整的本地事务，后续通过定时任务去扫描这个消息日志表中发送状态是非成功状态的消息记录，并将其发送到broker。后续下游事务操作的消费者收到这个消息再去做对应的业务处理。剩下需要考虑的问题就是消息的可靠性和幂等性问题。</p><p>消息的幂等性是指不能重复消费，收到一次这个消息和收到一百次这个消息最终的结果是一致的。一般做消息的幂等性的方案可以采用状态机。</p><p>消息的可靠性是指首先要保证消息正确发送到broker，另外消费者也需要正确消费。一般消息的可靠性主要依赖消息中间件的ack机制，比如生产者发送消息的时候基于broker的ack应答和消费者消费消息的手动ack等。</p><h4 id="_2-3-2、基于rocketmq事务消息" tabindex="-1"><a class="header-anchor" href="#_2-3-2、基于rocketmq事务消息"><span>2.3.2、基于RocketMQ事务消息</span></a></h4><p>Apache RocketMQ 4.3版本之后，开始支持事务消息，事务消息为分布式事务提供了非常方便的解决方案。RocketMQ的事务消息过程如下：</p><p><img src="http://blog.shengxiao.tech/images/image-20251224154023077.png" alt="image-20251224154023077"></p><p>也就是定义了消息的两种状态<code>中间状态</code>和<code>提交状态</code> ，对于中间状态的消息对于消费者是不可见的，只有经过commit的消息消费者才能正常消费。另外RocketMQ提供了执行本地事务和回查本地事务状态的接口，换句话说就是broker能够拿到事务的执行状态和结果，一旦本地事务执行成功，生产者就可以通知broker正常提交消息，反之就通知走回滚逻辑，而如果长时间没有接收到生产者的提交或回滚，RocketMQ就会调用回查接口拿到本地事务的状态：<code>UNKNOWN</code>、<code>COMMIT</code>、<code>ROLLBACK</code></p><h4 id="_2-3-2、tcc事务模型" tabindex="-1"><a class="header-anchor" href="#_2-3-2、tcc事务模型"><span>2.3.2、TCC事务模型</span></a></h4><p>TCC事务模型理论上也可以理解为2pc的模型，它将一个事务拆分成了Try、Confirm和Cancel三个操作，在try部分去完成业务逻辑，如果业务逻辑正常结束，则走confirm部分的事务提交逻辑，否则就走cancel部分的事务回滚逻辑，所以本质上是一种基于补偿的事务机制</p><p><img src="http://blog.shengxiao.tech/images/image-20251225115130897.png" alt="image-20251225115130897"></p><p>TCC使用起来相对复杂，它的控制权在业务开发者，业务开发者需要在每个分布式事务的业务操作中实现Try、Confirm、Cancel这三个方法</p><hr><p><img src="http://blog.shengxiao.tech/images/subscribe1.png" alt="扫码关注"></p>`,25))])}const v=l(c,[["render",b]]),x=JSON.parse('{"path":"/series/distribution/fenbushishiwu/01fenbushishiwudebeijinghejiejuefangan.html","title":"1、分布式事务的背景和解决方案","lang":"en-US","frontmatter":{"title":"1、分布式事务的背景和解决方案","date":"2025-12-25T08:05:36.000Z","categories":["分布式","事务"],"tags":["分布式","事务"]},"headers":[{"level":2,"title":"1、事务特性","slug":"_1、事务特性","link":"#_1、事务特性","children":[]},{"level":2,"title":"2、分布式事务理论","slug":"_2、分布式事务理论","link":"#_2、分布式事务理论","children":[{"level":3,"title":"2.1、X/OpenDTP（X/Open Distributed Transaction Processing Reference Model）","slug":"_2-1、x-opendtp-x-open-distributed-transaction-processing-reference-model","link":"#_2-1、x-opendtp-x-open-distributed-transaction-processing-reference-model","children":[]},{"level":3,"title":"2.2、基于XA协议的分布式事务框架","slug":"_2-2、基于xa协议的分布式事务框架","link":"#_2-2、基于xa协议的分布式事务框架","children":[]},{"level":3,"title":"2.3、基于可靠消息的最终一致性方案","slug":"_2-3、基于可靠消息的最终一致性方案","link":"#_2-3、基于可靠消息的最终一致性方案","children":[]}]}],"git":{"createdTime":1766801010000,"updatedTime":1766801010000,"contributors":[{"name":"qknavy","email":"qknavy@aliyun.com","commits":1}]},"filePathRelative":"series/distribution/分布式事务/01分布式事务的背景和解决方案.md"}');export{v as comp,x as data};
