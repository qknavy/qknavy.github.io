import{_ as i,c as l,a as r,b as e,d as t,e as n,r as h,o}from"./app-5XK5Q-SU.js";const p={},d={href:"https://gitee.com/qknavy/study/tree/master/arthas-demo",target:"_blank",rel:"noopener noreferrer"},c={href:"https://arthas.aliyun.com/doc/",target:"_blank",rel:"noopener noreferrer"};function g(m,a){const s=h("ExternalLinkIcon");return o(),l("div",null,[a[2]||(a[2]=r(`<div class="custom-container info"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="9"></circle><path d="M12 8h.01"></path><path d="M11 12h1v4h1"></path></g></svg><p class="custom-container-title">INFO</p><p>线上问题诊断利器-Arthas</p></div><h2 id="_1、arthas介绍" tabindex="-1"><a class="header-anchor" href="#_1、arthas介绍"><span>1、arthas介绍</span></a></h2><h3 id="_1-1、arthas是什么" tabindex="-1"><a class="header-anchor" href="#_1-1、arthas是什么"><span>1.1、arthas是什么</span></a></h3><p>Arthas 是阿里一款线上监控诊断产品，通过全局视角实时查看应用 load、内存、gc、线程的状态信息，并能在不修改应用代码的情况下，对业务问题进行诊断，包括查看方法调用的出入参、异常，监测方法执行耗时，类加载信息等，大大提升线上问题排查效率</p><h3 id="_1-2、arthas常用场景" tabindex="-1"><a class="header-anchor" href="#_1-2、arthas常用场景"><span>1.2、arthas常用场景</span></a></h3><p>arthas主要应用于以下这些场景中：</p><ul><li><p>这个类从哪个 jar 包加载的？为什么会报各种类相关的 Exception？</p></li><li><p>我改的代码为什么没有执行到？难道是我没 commit？分支搞错了？</p></li><li><p>遇到问题无法在线上 debug，难道只能通过加日志再重新发布吗？</p></li><li><p>线上遇到某个用户的数据处理有问题，但线上同样无法 debug，线下无法重现！</p></li><li><p>是否有一个全局视角来查看系统的运行状况？</p></li><li><p>有什么办法可以监控到 JVM 的实时运行状态？</p></li><li><p>怎么快速定位应用的热点，生成火焰图？</p></li><li><p>怎样直接从 JVM 内查找某个类的实例？</p></li></ul><h2 id="_2、下载安装" tabindex="-1"><a class="header-anchor" href="#_2、下载安装"><span>2、下载安装</span></a></h2><h3 id="_2-1、下载" tabindex="-1"><a class="header-anchor" href="#_2-1、下载"><span>2.1、下载</span></a></h3><p>github下载地址：https://github.com/alibaba/arthas/releases</p><p>下载指定版本的<code>arthas-bin.zip</code>文件即可，解压后内容如下：</p><p><img src="http://blog.shengxiao.tech/images/image-20250116104432950.png" alt="image-20250116104432950"></p><p>其中核心文件是<code>arthas-boot.jar</code>和<code>as.sh</code>或者<code>as.bat</code>。其中<code>arthas-boot.jar</code>文件可以直接通过<code>java -jar arths-boot.jar</code>的方式运行，<code>as.sh</code>是Linux或者mac下的运行文件，<code>as.bat</code>是Windows下的运行文件，但是这两个文件以脚本方式运行的话前提是需要安装<code>telnet</code></p><h3 id="_2-2、运行" tabindex="-1"><a class="header-anchor" href="#_2-2、运行"><span>2.2、运行</span></a></h3><p>我这里是通过<code>java -jar arthas-boot.jar</code>方式运行的，arthas启动后需要attach到某个Java进程里边，通过选择对应进程名称对应的编号即可，如下：</p><p><img src="http://blog.shengxiao.tech/images/image-20250116154947084.png" alt="image-20250116154947084"></p><p>我这里进入的是<code>com.study.arthas.ArthasDemoApplication</code>对应的3</p><h2 id="_3、操作" tabindex="-1"><a class="header-anchor" href="#_3、操作"><span>3、操作</span></a></h2><p>虽然前面介绍了arthas使用的一些常用场景，但是这里还是想从实际开发工作中可能会遇到的一些场景重点介绍几个重要的命令</p><h3 id="_3-1、dashboard监控" tabindex="-1"><a class="header-anchor" href="#_3-1、dashboard监控"><span>3.1、dashboard监控</span></a></h3><p>执行命令：</p><div class="language-bash line-numbers-mode" data-highlighter="prismjs" data-ext="sh" data-title="sh"><pre><code><span class="line"><span class="token comment"># dashboard [-i 数值] [-n 数值]，如下命令表示5s刷新一次</span></span>
<span class="line">dashboard <span class="token parameter variable">-i</span> <span class="token number">5000</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p><img src="http://blog.shengxiao.tech/images/image-20250116113457165.png" alt="image-20250116113457165"></p><p>第一部分打印出来的是线程信息，包括线程名称、线程组、线程状态、线程占用cpu资源情况等等</p><p>第二部分打印出来的是内存消耗情况，包括heap（s0、s1、以及老年代）、nonheap</p><p>第三部分是运行时环境，包括操作系统信息和jvm信息</p><h3 id="_3-2、heapdump堆栈信息" tabindex="-1"><a class="header-anchor" href="#_3-2、heapdump堆栈信息"><span>3.2、heapdump堆栈信息</span></a></h3><p>这个命令和jmap的heap dump相似，只不过用法不同</p><p>jmap dump堆栈信息的方式：<code>jmap -dump:live,format=b,file=heapdump.hprof &lt;pid&gt;</code></p><p>Arthas dump堆栈信息的方式：<code>heapdump --live arthas-output/dump.hprof</code> 看起来也更简洁了</p><h3 id="_3-3、jad反编译" tabindex="-1"><a class="header-anchor" href="#_3-3、jad反编译"><span>3.3、jad反编译</span></a></h3><p>有时候需要查看已经被加载的class文件的内容，jad命令就很有用了</p><p><img src="http://blog.shengxiao.tech/images/image-20250116155036463.png" alt="image-20250116155036463"></p><h3 id="_3-4、jvm查看jvm各参数" tabindex="-1"><a class="header-anchor" href="#_3-4、jvm查看jvm各参数"><span>3.4、jvm查看jvm各参数</span></a></h3><p>输出的内容太多了，就不贴了</p><h3 id="_3-5、logger日志相关" tabindex="-1"><a class="header-anchor" href="#_3-5、logger日志相关"><span>3.5、logger日志相关</span></a></h3><h4 id="_3-5-1、查看日志级别" tabindex="-1"><a class="header-anchor" href="#_3-5-1、查看日志级别"><span>3.5.1、查看日志级别</span></a></h4><p>如果要查看日志的级别，比如确认线上或测试环境的日志级别</p><div class="language-bash line-numbers-mode" data-highlighter="prismjs" data-ext="sh" data-title="sh"><pre><code><span class="line">logger <span class="token parameter variable">--name</span> ROOT</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p><img src="http://blog.shengxiao.tech/images/image-20250116135616074.png" alt="image-20250116135616074"></p><p>或者查看某个类或者包的日志级别</p><div class="language-bash line-numbers-mode" data-highlighter="prismjs" data-ext="sh" data-title="sh"><pre><code><span class="line">logger <span class="token parameter variable">--name</span> com.study.arthas.web.TestController</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p><img src="http://blog.shengxiao.tech/images/image-20250116135704724.png" alt="image-20250116135704724"></p><h4 id="_3-5-2、动态修改日志级别" tabindex="-1"><a class="header-anchor" href="#_3-5-2、动态修改日志级别"><span>3.5.2、动态修改日志级别</span></a></h4><p>上面看到<code>com.study.arthas.web.TestController</code>这个类的日志级别是<code>debug</code>，如果是线上环境全部都是info级别，现在要到线上去定位问题，想要放开这个类的所有debug日志怎么办呢，不可能修改配置文件然后重启吧？</p><p>这个时候就可以用arthas动态地去调整，如下所示就可以动态地将对应的类的日志级别调整为debug级别：</p><div class="language-bash line-numbers-mode" data-highlighter="prismjs" data-ext="sh" data-title="sh"><pre><code><span class="line">logger <span class="token parameter variable">--name</span> com.study.arthas.web.TestController <span class="token parameter variable">--level</span> debug</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>当然也可以批量指定某个ClassLoader加载的所有类的日志级别，用<code>-c ClassLoader的哈希值</code>参数</p><h3 id="_3-6、memory查看内存信息" tabindex="-1"><a class="header-anchor" href="#_3-6、memory查看内存信息"><span>3.6、memory查看内存信息</span></a></h3><p><img src="http://blog.shengxiao.tech/images/image-20250116140615686.png" alt="image-20250116140615686"></p><h3 id="_3-7、monitor监控" tabindex="-1"><a class="header-anchor" href="#_3-7、monitor监控"><span>3.7、monitor监控</span></a></h3><p>monitor可以监控方法的执行情况，比如我需要看一下自己写的方法的执行效率，则monitor是一个很方便工具，简单实用如下：</p><p><img src="http://blog.shengxiao.tech/images/image-20250116141541417.png" alt="image-20250116141541417"></p><p>方法拥有一个命名参数 <code>[c:]</code>，意思是统计周期（cycle of output），拥有一个整型的参数数值。上面每一行打印统计的都是5s之内对应的<code>sayHello</code>方法执行的统计信息，比如<strong>调用次数</strong>、<strong>成功次数</strong>、<strong>失败次数</strong>、<strong>平均响应时间rt</strong>、<strong>失败率</strong></p><h3 id="_3-8、搜索加载的类或方法" tabindex="-1"><a class="header-anchor" href="#_3-8、搜索加载的类或方法"><span>3.8、搜索加载的类或方法</span></a></h3><h4 id="_3-8-1、sc-search-class-搜索加载的类" tabindex="-1"><a class="header-anchor" href="#_3-8-1、sc-search-class-搜索加载的类"><span>3.8.1、sc(search class)搜索加载的类</span></a></h4><p><img src="http://blog.shengxiao.tech/images/image-20250116142150987.png" alt="image-20250116142150987"></p><h4 id="_3-8-2、sm-search-method-搜索某个类的方法" tabindex="-1"><a class="header-anchor" href="#_3-8-2、sm-search-method-搜索某个类的方法"><span>3.8.2、sm(search method)搜索某个类的方法</span></a></h4><p><img src="http://blog.shengxiao.tech/images/image-20250116142326613.png" alt="image-20250116142326613"></p><h3 id="_3-9、stack查看调用路径" tabindex="-1"><a class="header-anchor" href="#_3-9、stack查看调用路径"><span>3.9、stack查看调用路径</span></a></h3><p>很多时候我们都知道一个方法被执行，但这个方法被执行的路径非常多，或者你根本就不知道这个方法是从那里被执行了，此时你可以用到stack 命令</p><p><img src="http://blog.shengxiao.tech/images/image-20250116142817696.png" alt="image-20250116142817696"></p><p>这样就可以看出来是从<code>TestController</code>的26行调的<code>SayHelloService</code>里边的<code>sahHello</code>方法。其中的<code>-n </code>参数表示监听1次调用</p><p>不仅如此，stack还可以使用ognl表达式过滤，如我只监听参数为“Navy”的调用</p><p><img src="http://blog.shengxiao.tech/images/image-20250116143220500.png" alt="image-20250116143220500"></p><p>只有参数为Navy的时候才会往下执行</p><p><img src="http://blog.shengxiao.tech/images/image-20250116143401895.png" alt="image-20250116143401895"></p><p>也可以根据方法的调用耗时过滤，如表达式&quot;#cost&gt;5&quot;</p><h3 id="_3-10、thread线程管理" tabindex="-1"><a class="header-anchor" href="#_3-10、thread线程管理"><span>3.10、thread线程管理</span></a></h3><h4 id="_3-10-1、thread命令查看线程状态" tabindex="-1"><a class="header-anchor" href="#_3-10-1、thread命令查看线程状态"><span>3.10.1、thread命令查看线程状态</span></a></h4><p>直接执行thread命令可以查看线程的状态</p><p><img src="http://blog.shengxiao.tech/images/image-20250116143623789.png" alt="image-20250116143623789"></p><p>没有参数时打印第一页的线程，加<code>--all</code>参数打印所有线程</p><h4 id="_3-10-2、打印最忙的线程" tabindex="-1"><a class="header-anchor" href="#_3-10-2、打印最忙的线程"><span>3.10.2、打印最忙的线程</span></a></h4><p><img src="http://blog.shengxiao.tech/images/image-20250116143757056.png" alt="image-20250116143757056"></p><h4 id="_3-10-3、打印线程堆栈信息" tabindex="-1"><a class="header-anchor" href="#_3-10-3、打印线程堆栈信息"><span>3.10.3、打印线程堆栈信息</span></a></h4><p>使用命令<code>thread 线程ID</code>打印某个指定线程的堆栈信息，显示信息如上图</p><h4 id="_3-10-4、查看某个状态的线程" tabindex="-1"><a class="header-anchor" href="#_3-10-4、查看某个状态的线程"><span>3.10.4、查看某个状态的线程</span></a></h4><p>如下所示，查看waiting状态的所有线程</p><p><img src="http://blog.shengxiao.tech/images/image-20250116144222618.png" alt="image-20250116144222618"></p><h3 id="_3-11、trace查看调用路径" tabindex="-1"><a class="header-anchor" href="#_3-11、trace查看调用路径"><span>3.11、trace查看调用路径</span></a></h3><p>trace命令可以搜索对应方法的调用路径，渲染和统计整个调用链路上的所有性能开销和追踪调用链路，顾名思义有点链路追踪的意思</p><p><img src="http://blog.shengxiao.tech/images/image-20250116144639588.png" alt="image-20250116144639588"></p><p>示例监听了1次调用，并统计除了方法的调用路径，包括嵌套的方法的执行耗时。</p><p>但是这里可以看到下面两个方法调用的耗时相加并不等于上面的0.524538ms，这里还有一些隐藏的方法调用没有打印出来，比如jdk自带的方法被忽略了，可以通过增加<code>--skipJDKMethod false</code>参数打印出来。以及还有一些非函数调用（如i++）和jvm停顿时间消耗等等。</p><p>此外，trace和stack类似，也可以使用ognl表达式过滤</p><h3 id="_3-12、tt方法执行时空隧道" tabindex="-1"><a class="header-anchor" href="#_3-12、tt方法执行时空隧道"><span>3.12、tt方法执行时空隧道</span></a></h3><p>tt是TimeTunnel的简称，译为方法执行数据的时空隧道。记录下指定方法每次调用的入参和返回信息，并能对这些不同的时间下调用进行观测。这一点对我们线上问题排查将会是非常有用的，因为有时候我们并没有打印对应的入参出参等信息</p><h4 id="_3-12-1、记录调用信息" tabindex="-1"><a class="header-anchor" href="#_3-12-1、记录调用信息"><span>3.12.1、记录调用信息</span></a></h4><p><img src="http://blog.shengxiao.tech/images/image-20250116151744770.png" alt="image-20250116151744770"></p><p>这里的<code>-t</code>参数表示记录下对应方法每次的调用情况，<code>-n</code>参数表示记录1次</p><p>tt命令也支持ognl表达式</p><p><img src="http://blog.shengxiao.tech/images/image-20250116152332908.png" alt="image-20250116152332908"></p><h4 id="_3-12-2、检索调用记录" tabindex="-1"><a class="header-anchor" href="#_3-12-2、检索调用记录"><span>3.12.2、检索调用记录</span></a></h4><p><img src="http://blog.shengxiao.tech/images/image-20250116152502704.png" alt="image-20250116152502704"></p><h4 id="_3-12-3、查看调用明细" tabindex="-1"><a class="header-anchor" href="#_3-12-3、查看调用明细"><span>3.12.3、查看调用明细</span></a></h4><p><img src="http://blog.shengxiao.tech/images/image-20250116152525712.png" alt="image-20250116152525712"></p><p>各项信息顾名思义，可以看到方法是否是正常返回，参数值和返回值信息等。</p><h4 id="_3-12-4、重新调用" tabindex="-1"><a class="header-anchor" href="#_3-12-4、重新调用"><span>3.12.4、重新调用</span></a></h4><p>有的时候我们在联调的时候调用需要前端配合在前端操作，如果我们稍稍做了一些调整之后，可能需要前端系统重新触发一次我们的调用，那还需要联系前端，为了提升效率其实我们自己就可以操作，这里用到tt命令的重新调用机制，只需要通过<code>-p</code>参数就行</p><p><img src="http://blog.shengxiao.tech/images/image-20250116152922490.png" alt="image-20250116152922490"></p><p>通过 <code>--replay-times</code> 指定 调用次数，通过 <code>--replay-interval</code> 指定多次调用间隔(单位 ms, 默认 1000ms)。</p><h4 id="_3-12-5、注意事项" tabindex="-1"><a class="header-anchor" href="#_3-12-5、注意事项"><span>3.12.5、注意事项</span></a></h4><ul><li><strong>ThreadLocal 信息丢失</strong></li></ul><p>很多框架偷偷的将一些环境变量信息塞到了发起调用线程的 ThreadLocal 中，由于调用线程发生了变化，这些 ThreadLocal 线程信息无法通过 Arthas 保存，所以这些信息将会丢失。</p><ul><li><strong>引用的对象</strong></li></ul><p>需要强调的是，<code>tt</code> 命令是将当前环境的对象引用保存起来，但仅仅也只能保存一个引用而已。如果方法内部对入参进行了变更，或者返回的对象经过了后续的处理，那么在 <code>tt</code> 查看的时候将无法看到当时最准确的值。这也是为什么 <code>watch</code> 命令存在的意义</p><h3 id="_3-13、watch函数执行数据观测" tabindex="-1"><a class="header-anchor" href="#_3-13、watch函数执行数据观测"><span>3.13、watch函数执行数据观测</span></a></h3><p>功能类似trace、tt等，但主要目标是为了观察方法的执行情况，比如方法的请求入参、出参以及异常信息等</p><p>对应的观察表达式，默认值是<code>{params, target, returnObj}</code></p><p><img src="http://blog.shengxiao.tech/images/image-20250116153638827.png" alt="image-20250116153638827"></p><p>这里的<code>-x</code>参数表示输出结果的属性遍历深度，默认为 1，最大值是 4，<code>-n</code>参数表示监听调用的次数</p><p>可以看到<code>hello</code>方法的执行耗时(cost)，结果(result)信息里边第一个信息是入参(Navy)，出参(hello Navy)，目标信息(TestController)</p><p><strong>注意事项：</strong></p><ul><li>watch 命令定义了 4 个观察事件点，即 <code>-b</code> 函数调用前，<code>-e</code> 函数异常后，<code>-s</code> 函数返回后，<code>-f</code> 函数结束后</li><li>4 个观察事件点 <code>-b</code>、<code>-e</code>、<code>-s</code> 默认关闭，<code>-f</code> 默认打开，当指定观察点被打开后，在相应事件点会对观察表达式进行求值并输出</li><li>这里要注意<code>函数入参</code>和<code>函数出参</code>的区别，有可能在中间被修改导致前后不一致，除了 <code>-b</code> 事件点 <code>params</code> 代表函数入参外，其余事件都代表函数出参</li><li>当使用 <code>-b</code> 时，由于观察事件点是在函数调用前，此时返回值或异常均不存在</li><li>在 watch 命令的结果里，会打印出<code>location</code>信息。<code>location</code>有三种可能值：<code>AtEnter</code>，<code>AtExit</code>，<code>AtExceptionExit</code>。对应函数入口，函数正常 return，函数抛出异常。</li></ul>`,115)),e("p",null,[e("a",d,[a[0]||(a[0]=t("【示例工程代码】",-1)),n(s)])]),a[3]||(a[3]=e("p",null,[e("img",{src:"http://blog.shengxiao.tech/images/image-20250116160133916.png",alt:"image-20250116160133916"})],-1)),e("p",null,[e("a",c,[a[1]||(a[1]=t("【官网文档】",-1)),n(s)])]),a[4]||(a[4]=e("p",null,[e("img",{src:"http://blog.shengxiao.tech/images/image-20250116155336505.png",alt:"image-20250116155336505"})],-1)),a[5]||(a[5]=e("hr",null,null,-1)),a[6]||(a[6]=e("p",null,[e("img",{src:"http://blog.shengxiao.tech/images/subscribe1.png",alt:"扫码关注一起学习吧"})],-1))])}const u=i(p,[["render",g]]),_=JSON.parse('{"path":"/series/tools/jiankongyunwei/Arthasjibenyongfazhinan.html","title":"Arthas基本用法指南","lang":"en-US","frontmatter":{"title":"Arthas基本用法指南","date":"2025-01-17T00:00:00.000Z","categories":["小工具","java"],"tags":["小工具"]},"headers":[{"level":2,"title":"1、arthas介绍","slug":"_1、arthas介绍","link":"#_1、arthas介绍","children":[{"level":3,"title":"1.1、arthas是什么","slug":"_1-1、arthas是什么","link":"#_1-1、arthas是什么","children":[]},{"level":3,"title":"1.2、arthas常用场景","slug":"_1-2、arthas常用场景","link":"#_1-2、arthas常用场景","children":[]}]},{"level":2,"title":"2、下载安装","slug":"_2、下载安装","link":"#_2、下载安装","children":[{"level":3,"title":"2.1、下载","slug":"_2-1、下载","link":"#_2-1、下载","children":[]},{"level":3,"title":"2.2、运行","slug":"_2-2、运行","link":"#_2-2、运行","children":[]}]},{"level":2,"title":"3、操作","slug":"_3、操作","link":"#_3、操作","children":[{"level":3,"title":"3.1、dashboard监控","slug":"_3-1、dashboard监控","link":"#_3-1、dashboard监控","children":[]},{"level":3,"title":"3.2、heapdump堆栈信息","slug":"_3-2、heapdump堆栈信息","link":"#_3-2、heapdump堆栈信息","children":[]},{"level":3,"title":"3.3、jad反编译","slug":"_3-3、jad反编译","link":"#_3-3、jad反编译","children":[]},{"level":3,"title":"3.4、jvm查看jvm各参数","slug":"_3-4、jvm查看jvm各参数","link":"#_3-4、jvm查看jvm各参数","children":[]},{"level":3,"title":"3.5、logger日志相关","slug":"_3-5、logger日志相关","link":"#_3-5、logger日志相关","children":[]},{"level":3,"title":"3.6、memory查看内存信息","slug":"_3-6、memory查看内存信息","link":"#_3-6、memory查看内存信息","children":[]},{"level":3,"title":"3.7、monitor监控","slug":"_3-7、monitor监控","link":"#_3-7、monitor监控","children":[]},{"level":3,"title":"3.8、搜索加载的类或方法","slug":"_3-8、搜索加载的类或方法","link":"#_3-8、搜索加载的类或方法","children":[]},{"level":3,"title":"3.9、stack查看调用路径","slug":"_3-9、stack查看调用路径","link":"#_3-9、stack查看调用路径","children":[]},{"level":3,"title":"3.10、thread线程管理","slug":"_3-10、thread线程管理","link":"#_3-10、thread线程管理","children":[]},{"level":3,"title":"3.11、trace查看调用路径","slug":"_3-11、trace查看调用路径","link":"#_3-11、trace查看调用路径","children":[]},{"level":3,"title":"3.12、tt方法执行时空隧道","slug":"_3-12、tt方法执行时空隧道","link":"#_3-12、tt方法执行时空隧道","children":[]},{"level":3,"title":"3.13、watch函数执行数据观测","slug":"_3-13、watch函数执行数据观测","link":"#_3-13、watch函数执行数据观测","children":[]}]}],"git":{"createdTime":1765551376000,"updatedTime":1765551376000,"contributors":[{"name":"qknavy","email":"qknavy@aliyun.com","commits":1}]},"filePathRelative":"series/tools/监控运维/Arthas基本用法指南.md"}');export{u as comp,_ as data};
