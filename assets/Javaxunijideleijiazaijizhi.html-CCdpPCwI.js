import{_ as l,c as t,b as e,o as s}from"./app-D63_8prq.js";const i={};function r(d,a){return s(),t("div",null,[...a[0]||(a[0]=[e('<div class="custom-container tip"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="9"></circle><path d="M12 8h.01"></path><path d="M11 12h1v4h1"></path></g></svg><p class="custom-container-title">TIP</p><p>Java类的加载是指JVM将class信息加载到JVM内存的过程</p></div><h2 id="_1、类加载的过程" tabindex="-1"><a class="header-anchor" href="#_1、类加载的过程"><span>1、类加载的过程</span></a></h2><h3 id="_1-1、装载" tabindex="-1"><a class="header-anchor" href="#_1-1、装载"><span>1.1、装载</span></a></h3><blockquote><p>查找和导入class</p></blockquote><ul><li>通过类的全路径限定名从指定位置读取到代表这个类的二进制字节流</li><li>将这个二进制字节流转化为方法区的运行时数据结构</li><li>在堆中生成一个代表这个类的java.lang.Class对象，作为方法区中这些数据的访问入口</li></ul><h3 id="_1-2、链接" tabindex="-1"><a class="header-anchor" href="#_1-2、链接"><span>1.2、链接</span></a></h3><h4 id="_1-2-1、验证" tabindex="-1"><a class="header-anchor" href="#_1-2-1、验证"><span>1.2.1、验证</span></a></h4><ul><li>验证文件格式</li></ul><blockquote><p>比如验证文件的魔数是否是0xCAFEBABE，版本号是否正确</p></blockquote><ul><li>验证元数据信息</li></ul><blockquote><p>对元数据中的信息进行语义校验，也就是进行语法校验，保证文件符合Java的语法规范。比如： 1、是否有父类 2、是否继承了final类 3、非抽象类是否实现了抽象类的所有方法 ...</p></blockquote><ul><li>字节码验证</li></ul><blockquote><p>进行数据流和控制流分析，对方法进行校验，保证方法不对做出危害虚拟机安全的行为</p></blockquote><ul><li>符号引用验证</li></ul><blockquote><p>发生在第三个阶段”解析“阶段，可以理解为对类自身以外的信息进行匹配性验证，保证在符号引用能够被转化为直接引用，也就是保证解析动作能够正确执行。比如： 1、常量池中描述的类是否存在 2、访问的方法或者字段是否具有对应的访问权限</p><p>可以通过参数”-Xverify:none“来取消这一步的验证</p></blockquote><h4 id="_1-2-2、准备" tabindex="-1"><a class="header-anchor" href="#_1-2-2、准备"><span>1.2.2、准备</span></a></h4><p>为非final修饰的类变量分配内存地址，并设置默认值</p><blockquote><p>默认值：</p></blockquote><table><thead><tr><th>类型</th><th>默认值</th></tr></thead><tbody><tr><td>int</td><td>0</td></tr><tr><td>long</td><td>0L</td></tr><tr><td>short</td><td>(short)0</td></tr><tr><td>char</td><td>&#39;\\u0000&#39;</td></tr><tr><td>byte</td><td>(byte)0</td></tr><tr><td>boolean</td><td>false</td></tr><tr><td>float</td><td>0.0f</td></tr><tr><td>double</td><td>0.0d</td></tr><tr><td>reference</td><td>Null</td></tr></tbody></table><h4 id="_1-2-3、解析" tabindex="-1"><a class="header-anchor" href="#_1-2-3、解析"><span>1.2.3、解析</span></a></h4><p>动态地将运行时常量池里的符号引用转化为直接引用</p><h3 id="_1-3、初始化" tabindex="-1"><a class="header-anchor" href="#_1-3、初始化"><span>1.3、初始化</span></a></h3><p>实例变量初始化赋值</p><h2 id="_2、类加载机制" tabindex="-1"><a class="header-anchor" href="#_2、类加载机制"><span>2、类加载机制</span></a></h2><h3 id="_2-1、类加载的机制" tabindex="-1"><a class="header-anchor" href="#_2-1、类加载的机制"><span>2.1、类加载的机制</span></a></h3><p>类加载的过程中，主要遵守以下三个机制：</p><ul><li>全盘负责机制</li></ul><p>​ 当一个类加载器负责加载某个类的时候，这个类所依赖的和引用的类将都由这个类加载器去加载，除非有显示的指定某个加载器</p><ul><li><p>双亲委派机制</p></li><li><p>缓存机制</p></li></ul><p>​ 对于同一个类加载器，相同全限定名的类只加载一次，也就是loadClass()方法只会被执行一次。类加载完后会放到内存缓存中，每次加载的时候先会去缓存中看是否已经加载过，只有未曾被加载的类才会去对应路径下去找对应的字节码文件加载</p><h3 id="_2-2、双亲委派机制" tabindex="-1"><a class="header-anchor" href="#_2-2、双亲委派机制"><span>2.2、双亲委派机制</span></a></h3><p>①、ClassLoader首先判断类是否已经被加载，如果已经被加载，则返回对应的Class信息，否则就委托给父类加载器加载</p><p>②、父类加载器判断是否已经加载过这个类，如果已经加载过，则返回，如果没有，则委托给祖父类加载器加载</p><p>③、依此类推，直到始祖类加载器（Bootstrap ClassLoader）</p><p>④、始祖类加载器判断是否已经加载过这个类，如果加载过，则返回对应的Class信息，否则就从自己负责的类路径下去寻找对应的Class字节码文件，如果载入成功则返回Class信息，否则委托给始祖类加载器的子类加载器去加载</p><p>⑤、始祖类的子类加载器收到始祖类的“委托”，也先判断是否加载过这个类，如果加载过，则返回，否则也去自己管辖的classpath下去找对应类的字节码文件，如果加载成功则返回，否则继续委托给下一层的类加载器</p><p>⑥、依此类推，直到源ClassLoader</p><p>⑦、源ClassLoader也先判断一下是否已经加载过这个类，如果已经加载过，则返回，否则也去对应的类路径下去寻找对应的字节码文件并载入，如果载入成功，则返回Class信息，否则就会跑出ClassNotFoundException</p><h3 id="_2-3、如何打破双亲委派机制" tabindex="-1"><a class="header-anchor" href="#_2-3、如何打破双亲委派机制"><span>2.3、如何打破双亲委派机制</span></a></h3><ul><li>自定义ClassLoader，实现loadClass方法，要加载的类放在classpath之外，显示地指定要加载的路径setRoot，和loadClass(全限定符类名)</li><li>SPI机制</li><li>OSGI动态模块的加载与卸载</li><li>Spring Boot DevTools</li><li>Tomcat</li></ul><hr><p><img src="http://blog.shengxiao.tech/images/subscribe1.png" alt="扫码关注一起学习吧"></p>',42)])])}const o=l(i,[["render",r]]),p=JSON.parse('{"path":"/series/jvm/Javaxunijideleijiazaijizhi.html","title":"Java虚拟机的类加载机制","lang":"en-US","frontmatter":{"title":"Java虚拟机的类加载机制","date":"2025-07-02T00:00:00.000Z","categories":["jvm"],"tags":["jvm"]},"headers":[{"level":2,"title":"1、类加载的过程","slug":"_1、类加载的过程","link":"#_1、类加载的过程","children":[{"level":3,"title":"1.1、装载","slug":"_1-1、装载","link":"#_1-1、装载","children":[]},{"level":3,"title":"1.2、链接","slug":"_1-2、链接","link":"#_1-2、链接","children":[]},{"level":3,"title":"1.3、初始化","slug":"_1-3、初始化","link":"#_1-3、初始化","children":[]}]},{"level":2,"title":"2、类加载机制","slug":"_2、类加载机制","link":"#_2、类加载机制","children":[{"level":3,"title":"2.1、类加载的机制","slug":"_2-1、类加载的机制","link":"#_2-1、类加载的机制","children":[]},{"level":3,"title":"2.2、双亲委派机制","slug":"_2-2、双亲委派机制","link":"#_2-2、双亲委派机制","children":[]},{"level":3,"title":"2.3、如何打破双亲委派机制","slug":"_2-3、如何打破双亲委派机制","link":"#_2-3、如何打破双亲委派机制","children":[]}]}],"git":{"createdTime":1765551376000,"updatedTime":1765551376000,"contributors":[{"name":"qknavy","email":"qknavy@aliyun.com","commits":1}]},"filePathRelative":"series/jvm/Java虚拟机的类加载机制.md"}');export{o as comp,p as data};
