import{_ as l,c as i,a as e,b as n,d as p,e as t,r as o,o as c}from"./app-DpYkRorS.js";const r={},d={href:"https://dev.mysql.com/doc/refman/8.0/en/innodb-consistent-read.html",target:"_blank",rel:"noopener noreferrer"},u={href:"https://dev.mysql.com/doc/refman/8.0/en/performance-schema-data-locks-table.html",target:"_blank",rel:"noopener noreferrer"},m={href:"https://dev.mysql.com/doc/refman/8.0/en/innodb-locking.html#innodb-intention-locks",target:"_blank",rel:"noopener noreferrer"},k={href:"https://dev.mysql.com/doc/refman/8.0/en/innodb-parameters.html#sysvar_innodb_deadlock_detect",target:"_blank",rel:"noopener noreferrer"};function g(h,s){const a=o("ExternalLinkIcon");return c(),i("div",null,[s[4]||(s[4]=e('<div class="custom-container info"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="9"></circle><path d="M12 8h.01"></path><path d="M11 12h1v4h1"></path></g></svg><p class="custom-container-title">INFO</p><p>在前面的文章中，我们介绍了InnoDB的事务和数据一致性问题，也提到了为了解决这些问题MySQL提供了四个隔离级别供我们选择，对于InnoDB默认使用的是可重复度（RR）。而且也通过示例验证了在RR这个隔离级别下，InnoDB是解决了脏读、幻读和不可重复读的问题。</p></div><p>那么它是怎么解决的呢？</p><p>首先介绍一个东西，我们通常称为“MVCC”，官网把这个叫”无锁化一致性读“。我们姑且还是按照惯例叫MVCC吧。</p>',3)),n("p",null,[n("a",d,[s[0]||(s[0]=p("参考资料",-1)),t(a)])]),s[5]||(s[5]=e(`<h2 id="_1、mvcc" tabindex="-1"><a class="header-anchor" href="#_1、mvcc"><span>1、MVCC</span></a></h2><p>在介绍mvcc之前需要有一个概念，MySQL的数据行中其实是有一些隐藏列的，比如<code>DB_ROW_ID</code>记录了数据行ID、<code>DB_TRX_ID</code>最后修改当前记录的事务ID、<code>DB_ROLL_PTR</code>记录了数据被改动前的undolog日志指针</p><p>至于多版本控制，它的原理是基于快照。而这个快照，按照官网的介绍就是一个叫ReadView的东西，那就先来认识一下这个ReadView吧</p><h3 id="_1-1、了解readview的结构" tabindex="-1"><a class="header-anchor" href="#_1-1、了解readview的结构"><span>1.1、了解ReadView的结构</span></a></h3><p>按照我们的常规思维，ReadView是用来解决事务问题的，那么它里边肯定会记录一些事务相关的信息，那么它的结构是什么样的呢？我们查阅资料发现它里边还真的有几个属性记录了一些事务ID</p><h4 id="_1-1-1、m-low-limit-id" tabindex="-1"><a class="header-anchor" href="#_1-1-1、m-low-limit-id"><span>1.1.1、m_low_limit_id</span></a></h4><p>事务的高水位，当数据的修改事务id大于或等于这个值的时候，则该数据对当前事务不可见。这个值通常就是当前事务的下一个事务，就像我们的自增ID一样，事务ID也是一个自增的过程</p><p>这个逻辑很容易理解，你的事务ID都比我大，也就是说数据修改在我之后</p><h4 id="_1-1-2、m-up-limit-id" tabindex="-1"><a class="header-anchor" href="#_1-1-2、m-up-limit-id"><span>1.1.2、m_up_limit_id</span></a></h4><p>数据修改的事务ID所有小于这个值的数据都可见，也称低水位。这个值也是m_ids列表里边的最小值。既然都比当前存活的最小事务ID还小，那指定在当前事务创建之前已经提交了，所以就可见</p><h4 id="_1-1-3、m-creator-trx-id" tabindex="-1"><a class="header-anchor" href="#_1-1-3、m-creator-trx-id"><span>1.1.3、m_creator_trx_id</span></a></h4><p>当前的事务ID</p><h4 id="_1-1-4、m-ids" tabindex="-1"><a class="header-anchor" href="#_1-1-4、m-ids"><span>1.1.4、m_ids</span></a></h4><p>当前存活的事务ID列表，也就是创建当前<code>ReadView</code>的时候那么还没有提交的事务</p><h3 id="_1-2、可见性判断" tabindex="-1"><a class="header-anchor" href="#_1-2、可见性判断"><span>1.2、可见性判断</span></a></h3><p>上面在说到ReadView的结构的时候<code>&gt;= m_low_limit_id</code>和<code>&lt; m_up_limit_id</code>这两种情况基本上比较明确的，大于等于高水位不可见，小于低水位可见</p><p>但是如果数据修改的事务ID介于这两者之间怎么办呢？</p><p>这就联系到前面提到的数据行的隐藏列<code>DB_TRX_ID</code>了，这个场景规则也很简单：</p><p>① 如果数据的修改事务ID在上面提到的当前存活事务ID列表中，则说明在创建当前ReadView的时候修改数据的事务还没提交，则不可见</p><p>② 如果数据的修改事务ID不在上面的这个存活事务ID列表中，说明在创建当前ReadView的时候它已经被提交了，则可见</p><p>答案就这么水灵灵地出现了吗？没那么简单。前面我还埋了一个伏笔故意没提，那就是ReadView的创建是和隔离级别有关系的：在RC这种隔离级别下，他是每次查询都会创建一个新的ReadView，而在RR这个隔离级别下，只有在事务第一次读取的时候才会创建一个ReadView</p><p>所以不妨自己脑补一下这两种创建ReadView的时机会有什么影响</p><h3 id="_1-3、mvcc是如何解决不可重复读的" tabindex="-1"><a class="header-anchor" href="#_1-3、mvcc是如何解决不可重复读的"><span>1.3、MVCC是如何解决不可重复读的</span></a></h3><h4 id="_1-3-1、rc隔离级别下" tabindex="-1"><a class="header-anchor" href="#_1-3-1、rc隔离级别下"><span>1.3.1、RC隔离级别下</span></a></h4><p>按照1.2的判断逻辑，如果是在RC隔离级别下，每次快照读的时候都会创建一个ReadView，那么数据是否可见是用数据行的隐藏字段<code>DB_TRX_ID</code>去跟不同的ReadView里边的那几个字段去比较，显然不同的ReadView就有可能会有不同的比对结果。这是不是就会导致可能我第一次读取的时候生成的ReadView去判断，结果某条数据是不可见的，但是在第二次去读取的时候第二次的ReadView去比对得到的结果却是可见呢？</p><p>这种现象叫什么，是不是叫不可重复读？所以RC这种隔离级别下是没有解决不可重复读的问题的</p><h4 id="_1-3-2、rr隔离级别下" tabindex="-1"><a class="header-anchor" href="#_1-3-2、rr隔离级别下"><span>1.3.2、RR隔离级别下</span></a></h4><p>但是如果是在RR这种隔离级别下呢？</p><p>它和RC的不同点在于是在事务第一次快照读的时候生成一个ReadView，也就是说不管是第一次读取还是第二次读取，它去和数据的修改事务ID比对的ReadView是同一个。既然是同一个，那么比对的结果自然是前后一样的。换句话说，如果一条数据第一次读取的时候是不可见的，那么同一个事务第二次再读取依然是不可见，反之两次都是可见</p><p>这不就解决了数据一致性里边的不可重复读吗？</p><h2 id="_2、锁-lbcc" tabindex="-1"><a class="header-anchor" href="#_2、锁-lbcc"><span>2、锁（LBCC）</span></a></h2><p>前面通过分析ReadView已经知道RR隔离级别下，InnoDB是如何解决不可重复读的问题的。接下来我们要弄清楚InnoDB是如何在RR级别下解决幻读的问题的</p><p>回忆一下什么是幻读，是不是一个事务在进行范围查询的时候，第一查询的结果和第二次查询的结果不一样？比如我有一个事务A：</p><div class="language-sql line-numbers-mode" data-highlighter="prismjs" data-ext="sql" data-title="sql"><pre><code><span class="line"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> coupon_code <span class="token keyword">where</span> <span class="token keyword">type</span> <span class="token operator">&gt;</span> <span class="token number">2</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>事务B这个时候插入了一条type=3的记录：</p><div class="language-sql line-numbers-mode" data-highlighter="prismjs" data-ext="sql" data-title="sql"><pre><code><span class="line"><span class="token keyword">insert</span> <span class="token keyword">into</span> coupon_code<span class="token punctuation">(</span>code<span class="token punctuation">,</span> <span class="token keyword">type</span><span class="token punctuation">.</span> <span class="token keyword">status</span><span class="token punctuation">)</span> <span class="token keyword">values</span><span class="token punctuation">(</span><span class="token string">&#39;176231512&#39;</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>上一篇我们通过示例验证了在RR隔离级别下事务A查到的数据始终是一致的，也就是没有出现幻读的问题。它是怎么解决的呢？</p><p>答案就是<strong>锁</strong>。</p><p>在InnoDB中，存储引擎的锁操作是加在索引树上的，如果我们加锁的语句通过条件能够定位到对应的记录，那么就会锁住对应的主键索引。接下来我们验证一下：</p><p>首先有一张学生表：</p><div class="language-sql line-numbers-mode" data-highlighter="prismjs" data-ext="sql" data-title="sql"><pre><code><span class="line"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token identifier"><span class="token punctuation">\`</span>stu<span class="token punctuation">\`</span></span> <span class="token punctuation">(</span></span>
<span class="line">  <span class="token identifier"><span class="token punctuation">\`</span>id<span class="token punctuation">\`</span></span> <span class="token keyword">int</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">AUTO_INCREMENT</span><span class="token punctuation">,</span></span>
<span class="line">  <span class="token identifier"><span class="token punctuation">\`</span>stu_no<span class="token punctuation">\`</span></span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">255</span><span class="token punctuation">)</span> <span class="token keyword">CHARACTER</span> <span class="token keyword">SET</span> utf8mb4 <span class="token keyword">COLLATE</span> utf8mb4_general_ci <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span></span>
<span class="line">  <span class="token identifier"><span class="token punctuation">\`</span>stu_name<span class="token punctuation">\`</span></span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">255</span><span class="token punctuation">)</span> <span class="token keyword">CHARACTER</span> <span class="token keyword">SET</span> utf8mb4 <span class="token keyword">COLLATE</span> utf8mb4_general_ci <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span></span>
<span class="line">  <span class="token identifier"><span class="token punctuation">\`</span>age<span class="token punctuation">\`</span></span> <span class="token keyword">int</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span></span>
<span class="line">  <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span><span class="token identifier"><span class="token punctuation">\`</span>id<span class="token punctuation">\`</span></span><span class="token punctuation">)</span></span>
<span class="line"><span class="token punctuation">)</span> <span class="token keyword">ENGINE</span><span class="token operator">=</span><span class="token keyword">InnoDB</span> <span class="token keyword">DEFAULT</span> <span class="token keyword">CHARSET</span><span class="token operator">=</span>utf8mb4 <span class="token keyword">COLLATE</span><span class="token operator">=</span>utf8mb4_general_ci<span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>表中有四条记录：</p><p><img src="http://blog.shengxiao.tech/images/image-20241124210239155.png" alt="image-20241124210239155"></p><p>如果我们在一个事务里查询：</p><div class="language-sql line-numbers-mode" data-highlighter="prismjs" data-ext="sql" data-title="sql"><pre><code><span class="line"><span class="token keyword">BEGIN</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">from</span> stu <span class="token keyword">WHERE</span> id <span class="token operator">=</span> <span class="token number">2</span> <span class="token keyword">FOR</span> <span class="token keyword">UPDATE</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p><img src="http://blog.shengxiao.tech/images/image-20241124210357435.png" alt="image-20241124210357435"></p><p>另外一个事务去修改这条记录：</p><div class="language-sql line-numbers-mode" data-highlighter="prismjs" data-ext="sql" data-title="sql"><pre><code><span class="line"><span class="token keyword">BEGIN</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">UPDATE</span> stu <span class="token keyword">SET</span> stu_name <span class="token operator">=</span> <span class="token string">&#39;HanMeiMei001&#39;</span> <span class="token keyword">WHERE</span> id <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>可以看到SQL语句被阻塞了，直到最终锁等待超时：</p><p><img src="http://blog.shengxiao.tech/images/image-20241124210518985.png" alt="image-20241124210518985"></p><p><img src="http://blog.shengxiao.tech/images/image-20241124210637063.png" alt="image-20241124210637063"></p><p>如果我不根据ID条件去修改，而是根据stu_name去修改呢？可以看到效果一样：</p><p><img src="http://blog.shengxiao.tech/images/image-20241124210800841.png" alt="image-20241124210800841"></p><p>这个时候如果是修改其他的记录呢，不是锁定的ID=2这一条，比如我要修改ID=3的Lucy的名字：</p><p><img src="http://blog.shengxiao.tech/images/image-20241124211138458.png" alt="image-20241124211138458"></p><p>根据ID=3去修改，可以看到立马执行成功了。如果我根据stu_name或者stu_no去修改呢？试一下</p><p><img src="http://blog.shengxiao.tech/images/image-20241124211320394.png" alt="image-20241124211320394"></p><p>啊哦，又要等待了，这是为啥呢？</p><p>其实这里的原因在于加锁的条件。update或者DELETE的时候会自动去加一个排它锁（后面讲到），像第一次根据ID去update的时候，InnoDB可以定位到具体的某一条记录，所以它锁的是ID=2这一条记录，而如果是通过stu_no或者stu_name去update的时候，因为这两个字段也没有建立索引，所以它无法定位到某一条具体的记录需要全表扫描，这个时候InnoDB就会选择去锁表。但是由于第一个事务一直对ID=2这条记录的排它锁没有释放呢，所以第二个事务的锁表操作一直在等待直到50s后超时</p><h3 id="_2-1、如何查看当前存在的锁" tabindex="-1"><a class="header-anchor" href="#_2-1、如何查看当前存在的锁"><span>2.1、如何查看当前存在的锁</span></a></h3><p>之前文章介绍过MySQL里有一个库<code>performance_schema</code>记录的就是MySQL运行时的一些信息，其中<code>data_locks</code>表就是记录锁的一些信息：</p><div class="language-sql line-numbers-mode" data-highlighter="prismjs" data-ext="sql" data-title="sql"><pre><code><span class="line"><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">from</span> performance_schema<span class="token punctuation">.</span>data_locks</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p><img src="http://blog.shengxiao.tech/images/image-20241124215457755.png" alt="image-20241124215457755"></p><p>这里可以看到线程ID、数据库名称、加锁的索引、锁的模式（共享S、排它X、意向共享IS、意向排它IX）等</p>`,64)),n("p",null,[n("a",u,[s[1]||(s[1]=p("【参考资料】",-1)),t(a)])]),s[6]||(s[6]=e('<h3 id="_2-2、锁的分类" tabindex="-1"><a class="header-anchor" href="#_2-2、锁的分类"><span>2.2、锁的分类</span></a></h3><h4 id="_2-2-1、按照占有模式" tabindex="-1"><a class="header-anchor" href="#_2-2-1、按照占有模式"><span>2.2.1、按照占有模式</span></a></h4><ul><li>共享锁</li></ul><p>共享锁与共享锁之间可以实现资源共享</p><ul><li>排它锁</li></ul><p>排它锁与其它锁不兼容，在update或者DELETE的时候自带排它锁</p><h4 id="_2-2-2、按照锁的对象或粒度-锁的实现方式" tabindex="-1"><a class="header-anchor" href="#_2-2-2、按照锁的对象或粒度-锁的实现方式"><span>2.2.2、按照锁的对象或粒度（锁的实现方式）</span></a></h4><ul><li>记录锁</li></ul><p>通过条件能够查询到指定的某一条记录。记录锁锁定的一定是主键索引树，如果是通过二级索引加锁，最终还是会定位到主键索引的行节点然后锁主键索引。如果通过一个没有索引的字段去加锁，由于定位不到主键索引的对应节点，所以需要进行全表扫描，会触发锁表，就像前面演示的效果</p><ul><li>间隙锁</li></ul><p>加入加锁的条件是一个区间，这个区间锁死，下面演示一下：</p><blockquote><p>前面提到如果加锁的条件如果没有命中索引（主键索引或者二级索引都可以），也就无法定位到对应的记录ID，也就是说会触发全表锁定。下面的示例主要根据age操作，所以需要先给age加一个索引</p><div class="language-sql line-numbers-mode" data-highlighter="prismjs" data-ext="sql" data-title="sql"><pre><code><span class="line"><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> <span class="token identifier"><span class="token punctuation">`</span>test001<span class="token punctuation">`</span></span><span class="token punctuation">.</span><span class="token identifier"><span class="token punctuation">`</span>stu<span class="token punctuation">`</span></span> </span>\n<span class="line"><span class="token keyword">ADD</span> <span class="token keyword">INDEX</span> <span class="token identifier"><span class="token punctuation">`</span>idx_age<span class="token punctuation">`</span></span><span class="token punctuation">(</span><span class="token identifier"><span class="token punctuation">`</span>age<span class="token punctuation">`</span></span><span class="token punctuation">)</span> <span class="token keyword">USING</span> <span class="token keyword">BTREE</span><span class="token punctuation">;</span></span>\n<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div></blockquote><p>第一个事务去查询年龄在(12,16)岁之间的，可以看到只有一条记录</p><div class="language-sql line-numbers-mode" data-highlighter="prismjs" data-ext="sql" data-title="sql"><pre><code><span class="line"><span class="token keyword">BEGIN</span><span class="token punctuation">;</span></span>\n<span class="line"><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> stu <span class="token keyword">WHERE</span> age <span class="token operator">&gt;</span> <span class="token number">12</span> <span class="token operator">and</span> age <span class="token operator">&lt;</span> <span class="token number">16</span> <span class="token keyword">FOR</span> <span class="token keyword">UPDATE</span><span class="token punctuation">;</span></span>\n<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p><img src="http://blog.shengxiao.tech/images/image-20241124212757527.png" alt="image-20241124212757527"></p><p>第二个事务插入一条14岁的LiLy</p><p><img src="http://blog.shengxiao.tech/images/image-20241124212648141.png" alt="image-20241124212648141"></p><p>又获取锁超时了：</p><p><img src="http://blog.shengxiao.tech/images/image-20241124212832858.png" alt="image-20241124212832858"></p><p>那么它锁定的是哪个范围呢？下面我们来插入几条数据试一下：</p><p>①插入一条11岁的：</p><p><img src="http://blog.shengxiao.tech/images/image-20241124213726362.png" alt="image-20241124213726362"></p><p>可以看到立即执行成功了</p><p>②插入一条12岁的：</p><p><img src="http://blog.shengxiao.tech/images/image-20241124213821937.png" alt="image-20241124213821937"></p><p>发现锁等待</p><p>③插入一条14岁的：</p><p><img src="http://blog.shengxiao.tech/images/image-20241124213918647.png" alt="image-20241124213918647"></p><p>也是等待</p><p>④插入一条15岁的：</p><p><img src="http://blog.shengxiao.tech/images/image-20241124214002022.png" alt="image-20241124214002022"></p><p>依然是要等待</p><p>⑤插入一条16岁的：</p><p><img src="http://blog.shengxiao.tech/images/image-20241124214039114.png" alt="image-20241124214039114"></p><p>依然是要等待：</p><p>⑥插入一条100岁的：</p><p><img src="http://blog.shengxiao.tech/images/image-20241124214136741.png" alt="image-20241124214136741"></p><p>还是要等待~</p><p><strong>分析</strong>：</p><blockquote><p>前面查看数据发现，数据库里存在的数据年龄有8、11、12、15。InnoDB在加间隙锁的时候会根据已有数据去划分区间，这个时候就会划分出这几个区间：(-∞,8]、(8,11]、(11,12]、(12,15]、(15,+∞)。在第一个事务的加锁条件是(12,16)，结合现象我们可以看出，InnoDB锁定的是(12,15]、(15,+∞)这两个区间</p></blockquote><p>正是有了间隙锁，区间被锁定后也就无法插入这个区间内的值，那么是不是就可以解决幻读的问题呢？但是间隙锁只有在RR隔离级别下才存在，在RC隔离级别下没有间隙锁，即使锁一个区间，也只是用作主键、唯一键的检查，所以RC隔离级别下幻读会依然存在，而RR隔离级别却解决了幻读的问题</p><ul><li>临键锁</li></ul><p>间隙+记录锁，就像上面案例锁定的这两个区间：(12,15]、(15,+∞)，其中既包含了不存在数据的两个区间，又包含了存在数据的age=15对应的记录</p><ul><li>意向锁</li></ul><p>InnoDB支持行锁与表锁共存，意向锁是锁优化的一种方案。比如前面提到如果加锁条件没有命中二级索引，就会触发全表扫描进行锁表。而有了意向锁之后，只需要检查目标表上的意向锁标志就可以判断是否能够加锁</p><p>意向共享锁加锁时机：</p><ul><li>行数据加共享锁之前，必须先获得对应表的意向共享锁</li><li>行数据加排它锁之前，必须先获得对应表的意向排它锁</li></ul>',47)),n("p",null,[n("a",m,[s[2]||(s[2]=p("【参考资料】",-1)),t(a)])]),s[7]||(s[7]=e(`<p>假如当一个事务给一条数据加了一个共享锁（in share mode），InnoDB会在这之前先对表加一个意向共享锁，这个时候如果第二个事务也是读操作（in share mode），则也会尝试先去加一个意向共享锁，而意向共享锁与共享锁之间是互相兼容的，也就不用继续锁等待；而如果第二个事务是写操作，并且写条件没有命中二级索引，我们知道它会触发上面说的全表扫描进而尝试锁表（加排它锁），这个时候它首先会判断表上面是否存在其它的锁，这个时候发现已经有其它事务加了一个意向共享锁，而意向共享锁和排它锁之间是不兼容的，所以第二个事务的写操作会直接进行锁等待，而不用再去做全表扫描；而如果第二个事务虽然是写操作，但是它命中了索引，也就是它的目标是给具体的行加排它锁，这个时候InnoDB会在加排它锁之前去获取对应表的意向排它锁，而意向共享锁与意向排它锁是互相兼容的，这个时候也就不需要进行锁等待</p><p>以第三种场景为例：</p><p>①事务A对一条数据加共享锁</p><div class="language-sql line-numbers-mode" data-highlighter="prismjs" data-ext="sql" data-title="sql"><pre><code><span class="line"><span class="token comment">-- 事务A</span></span>
<span class="line"><span class="token keyword">BEGIN</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> stu <span class="token keyword">WHERE</span> id <span class="token operator">=</span> <span class="token number">1</span> <span class="token keyword">FOR</span> <span class="token keyword">SHARE</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><img src="http://blog.shengxiao.tech/images/image-20241125101338016.png" alt="image-20241125101338016"></p><p>锁信息：</p><p><img src="http://blog.shengxiao.tech/images/image-20241125102111279.png" alt="image-20241125102111279"></p><p>②事务B去修改ID=3的这条数据</p><div class="language-sql line-numbers-mode" data-highlighter="prismjs" data-ext="sql" data-title="sql"><pre><code><span class="line"><span class="token comment">-- 事务B</span></span>
<span class="line"><span class="token keyword">BEGIN</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">update</span> stu <span class="token keyword">set</span> stu_name<span class="token operator">=</span><span class="token string">&#39;Jerry&#39;</span> <span class="token keyword">where</span> id <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><img src="http://blog.shengxiao.tech/images/image-20241125102215943.png" alt="image-20241125102215943"></p><p><img src="http://blog.shengxiao.tech/images/image-20241125102452110.png" alt="image-20241125102452110"></p><p>可以看到，ID=3的这条记录成功被修改</p><blockquote><p>可见意向共享锁和意向排它锁之间是互相兼容的</p></blockquote><p>不同的表级别的锁之间的兼容性如下图：</p><p><img src="http://blog.shengxiao.tech/images/image-20241125095029136.png" alt="image-20241125095029136"></p><blockquote><p>X：排它锁</p><p>S：共享锁</p><p>IX：意向排它锁</p><p>IS：意向共享锁</p></blockquote><h3 id="_2-3、死锁问题" tabindex="-1"><a class="header-anchor" href="#_2-3、死锁问题"><span>2.3、死锁问题</span></a></h3><p>死锁的现象：你等我，我等你。下面举例说明：</p><blockquote><p>前面提到update、delete都会默认加一个排它锁</p></blockquote><p><img src="http://blog.shengxiao.tech/images/image-20241125090814925.png" alt="image-20241125090814925"></p><div class="language-sql line-numbers-mode" data-highlighter="prismjs" data-ext="sql" data-title="sql"><pre><code><span class="line"><span class="token comment">-- 事务A：</span></span>
<span class="line"><span class="token keyword">BEGIN</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">update</span> stu <span class="token keyword">set</span> stu_name<span class="token operator">=</span><span class="token string">&#39;Tom&#39;</span> <span class="token keyword">where</span> id <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><img src="http://blog.shengxiao.tech/images/image-20241125091127710.png" alt="image-20241125091127710"></p><div class="language-sql line-numbers-mode" data-highlighter="prismjs" data-ext="sql" data-title="sql"><pre><code><span class="line"><span class="token comment">-- 事务B</span></span>
<span class="line"><span class="token keyword">BEGIN</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">update</span> stu <span class="token keyword">set</span> stu_name<span class="token operator">=</span><span class="token string">&#39;Jerry&#39;</span> <span class="token keyword">where</span> id <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><img src="http://blog.shengxiao.tech/images/image-20241125091157744.png" alt="image-20241125091157744"></p><p>接下来事务A去更新ID=2的数据</p><div class="language-sql line-numbers-mode" data-highlighter="prismjs" data-ext="sql" data-title="sql"><pre><code><span class="line"><span class="token comment">-- 事务A</span></span>
<span class="line"><span class="token keyword">update</span> stu <span class="token keyword">set</span> stu_name<span class="token operator">=</span><span class="token string">&#39;Daul&#39;</span> <span class="token keyword">where</span> id <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p><img src="http://blog.shengxiao.tech/images/image-20241125091442488.png" alt="image-20241125091442488"></p><p>事务B去更新ID=1的数据</p><div class="language-sql line-numbers-mode" data-highlighter="prismjs" data-ext="sql" data-title="sql"><pre><code><span class="line"><span class="token comment">-- 事务B</span></span>
<span class="line"><span class="token keyword">update</span> stu <span class="token keyword">set</span> stu_name<span class="token operator">=</span><span class="token string">&#39;MiMi&#39;</span> <span class="token keyword">where</span> id <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p><img src="http://blog.shengxiao.tech/images/image-20241125091504487.png" alt="image-20241125091504487"></p><blockquote><p>可以看到，事务B在执行的时候报错了，提示发现了死锁</p><p>在MySQL的新版本中，InnoDB是支持死锁自动检测的，所以原则上不会出现两个事务一直在互相等待锁的死锁问题，但是从实践出发，我们还是要尽可能地避免死锁的出现</p></blockquote>`,31)),n("p",null,[n("a",k,[s[3]||(s[3]=p("【参考资料】",-1)),t(a)])]),s[8]||(s[8]=n("p",null,[n("strong",null,"MySQL死锁检测机制")],-1)),s[9]||(s[9]=n("ul",null,[n("li",null,"尽量减少耗时的事务（减少锁的持有时间）"),n("li",null,"尽量减少锁定的数据量（减少锁的粒度）")],-1)),s[10]||(s[10]=n("hr",null,null,-1)),s[11]||(s[11]=n("p",null,[n("img",{src:"http://blog.shengxiao.tech/images/subscribe1.png",alt:"扫码关注"})],-1))])}const v=l(r,[["render",g]]),w=JSON.parse('{"path":"/series/db/mysql/06MySQLduobanbenkongzhi(MVCC)hesuo.html","title":"6、MySQL多版本控制（MVCC）和锁","lang":"en-US","frontmatter":{"title":"6、MySQL多版本控制（MVCC）和锁","date":"2024-11-14T00:00:00.000Z","categories":["mysql","数据库"],"tags":["mysql","数据库"]},"headers":[{"level":2,"title":"1、MVCC","slug":"_1、mvcc","link":"#_1、mvcc","children":[{"level":3,"title":"1.1、了解ReadView的结构","slug":"_1-1、了解readview的结构","link":"#_1-1、了解readview的结构","children":[]},{"level":3,"title":"1.2、可见性判断","slug":"_1-2、可见性判断","link":"#_1-2、可见性判断","children":[]},{"level":3,"title":"1.3、MVCC是如何解决不可重复读的","slug":"_1-3、mvcc是如何解决不可重复读的","link":"#_1-3、mvcc是如何解决不可重复读的","children":[]}]},{"level":2,"title":"2、锁（LBCC）","slug":"_2、锁-lbcc","link":"#_2、锁-lbcc","children":[{"level":3,"title":"2.1、如何查看当前存在的锁","slug":"_2-1、如何查看当前存在的锁","link":"#_2-1、如何查看当前存在的锁","children":[]},{"level":3,"title":"2.2、锁的分类","slug":"_2-2、锁的分类","link":"#_2-2、锁的分类","children":[]},{"level":3,"title":"2.3、死锁问题","slug":"_2-3、死锁问题","link":"#_2-3、死锁问题","children":[]}]}],"git":{"createdTime":1765551376000,"updatedTime":1765551376000,"contributors":[{"name":"qknavy","email":"qknavy@aliyun.com","commits":1}]},"filePathRelative":"series/db/mysql/06MySQL多版本控制(MVCC)和锁.md"}');export{v as comp,w as data};
