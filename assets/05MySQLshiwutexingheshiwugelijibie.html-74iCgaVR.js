import{_ as p,c as t,a as n,b as a,d as l,e as o,r as i,o as c}from"./app-CUmx0lpF.js";const r={},d={href:"https://dev.mysql.com/doc/refman/8.0/en/mysql-acid.html",target:"_blank",rel:"noopener noreferrer"};function k(u,s){const e=i("ExternalLinkIcon");return c(),t("div",null,[s[1]||(s[1]=n('<div class="custom-container info"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="9"></circle><path d="M12 8h.01"></path><path d="M11 12h1v4h1"></path></g></svg><p class="custom-container-title">INFO</p><p>简单分析事务的ACID特性和存在的数据一致性问题，再介绍了一下MySQL的事务隔离级别</p></div><h2 id="_1、mysql的事务特性" tabindex="-1"><a class="header-anchor" href="#_1、mysql的事务特性"><span>1、MySQL的事务特性</span></a></h2><p>事务是工作的原子单元，可以提交或回滚。当事务对数据库进行多个更改时，要么在事务提交时所有更改都成功，要么在事务回滚时所有更改都被撤消。</p><p>但是在MySQL常用的这些存储引擎中，也只有InnoDB存储引擎才支持事务</p><p><img src="http://blog.shengxiao.tech/images/image-20241112210928944.png" alt="image-20241112210928944"></p><p>从事务的概念出发，事务的特性表现在以下四个方面</p>',6)),a("p",null,[a("a",d,[s[0]||(s[0]=l("参考资料",-1)),o(e)])]),s[2]||(s[2]=n(`<h3 id="_1-1、原子性" tabindex="-1"><a class="header-anchor" href="#_1-1、原子性"><span>1.1、原子性</span></a></h3><p>所谓原子性（Atomicity），就是我们的多个操作是一起执行的，要么一起提交，要么一起回滚。主要是通过<code>commit</code>、<code>rollback</code>、<code>autocommit</code>来控制事务的提交与否</p><p>但是数据库默认是自动提交的，比如我们用navicat执行一个DML语句，事务会在我们语句执行完成后自动提交。想要手动提交事务，就需要用<code>begin</code>或者<code>start transaction</code>手动开启一个事务，或者将<code>autocommit</code>设置为false</p><p>数据库的原子性和我们之前学习并发编程的时候提到的“原子性”有点相似，但还是有一些不一样的。并发编程里的原子性主要表现在一个线程对一个资源操作的时候其它线程不能同时去动它，而数据库事务里的原子性重点在要么同时提交，要么一起回滚。</p><h3 id="_1-2、一致性" tabindex="-1"><a class="header-anchor" href="#_1-2、一致性"><span>1.2、一致性</span></a></h3><p>数据库的一致性（Consistency），顾名思义就是要保证数据库数据的一致性。不能因为外界的一些因素，比如突然断电等的影响而出现和预期的不一致的情况。</p><p>数据库在保证一致性方面有哪些机制呢？</p><p>首先就是<strong>双写机制</strong>，也就是doublewrite。数据库在将有数据更新的脏页写入磁盘之前会有一个双写的过程，由于这个过程是顺序I/O，性能比刷脏时候的随机I/O强很多，所以基本上能保证提交的数据能够被“备份”到doublewrite空间</p><p>其次，InnoDB为了应对MySQL突然崩溃的场景准备了一个<strong>redolog</strong>，前面在介绍InnoDB的表空间的时候提到这块空间有一个独立的redolog表空间。它的工作原理和doublewrite类似，就是在数据提交的同时会写一份redolog日志，也是顺序I/O，如果真的碰到了MySQL崩溃的情况，在下次服务起来的时候会从redolog日志中进行数据恢复。</p><h3 id="_1-3、隔离性" tabindex="-1"><a class="header-anchor" href="#_1-3、隔离性"><span>1.3、隔离性</span></a></h3><p>隔离性（Isolation）是指不同事务对数据的操作对彼此的影响。这块直接关系到我们读取的数据是否是我们理想的数据，也是我们讨论最多的一个特性。这里留到后面讲事务的隔离级别的时候细聊。</p><h3 id="_1-4、持久性" tabindex="-1"><a class="header-anchor" href="#_1-4、持久性"><span>1.4、持久性</span></a></h3><p>事务的持久性（Durability）毫无疑问，比如已经被事务提交的数据不能平白无故地丢了，必须要尽可能地同步到磁盘做好持久化。</p><p>为了保证事务的持久性，InnoDB主要依赖以下几个重要机制：</p><ul><li>双写，保证内存同步到磁盘，就算page损坏的情况下也能恢复。</li><li>RedoLog机制</li><li>binlog的同步机制</li><li>独立表空间或者系统表空间 设置</li></ul><h2 id="_2、事务的隔离级别" tabindex="-1"><a class="header-anchor" href="#_2、事务的隔离级别"><span>2、事务的隔离级别</span></a></h2><h3 id="_2-1、数据一致性问题" tabindex="-1"><a class="header-anchor" href="#_2-1、数据一致性问题"><span>2.1、数据一致性问题</span></a></h3><p>数据的一致性问题是我们最关心的问题之一，也是讨论最多的问题，经常在面试中也会被问到有哪些数据一致性问题，MySQL是如何解决的。</p><ul><li>脏读</li></ul><p>所谓脏读就是一个事务读取到了另外一个线程还没提交的数据。如果这时候给它读出来了，回头人家转过头就回滚了，那读到的就是一条不应该存在的数据</p><p><img src="http://blog.shengxiao.tech/images/image-20241112215824847.png" alt="image-20241112215824847"></p><p>像这样一个事务读到另外一个事务未提交的数据，这就叫<strong>脏读</strong></p><ul><li>幻读</li></ul><p>当一个事务在进行范围查询的时候，另外一个事务刚好往这个范围区间内插入了新的记录，导致第一个事务前后查询的时候查出来的结果不一致，这就叫<strong>幻读</strong>，如下图所示：</p><p><img src="http://blog.shengxiao.tech/images/image-20241112220705972.png" alt="image-20241112220705972"></p><blockquote><p>第二次查询可能就会比第一次查询多出来一条</p></blockquote><ul><li>不可重复读</li></ul><p>当一个事务查询数据的时候，另外一个事务对这个数据进行了修改或者删除，导致第二次查询的时候查询出来的结果和第一次查询的结果不一样，如下图所示：</p><p><img src="http://blog.shengxiao.tech/images/image-20241112221148745.png" alt="image-20241112221148745"></p><blockquote><p>这个时候第二次查询的优惠券码就是<code>723532</code>了，而不再试第一次查询得到的结果</p></blockquote><p>这种场景下出现前后两次查询的结果不一样的问题叫<strong>不可重复读</strong>问题</p><h3 id="_2-2、mysql的事务隔离级别" tabindex="-1"><a class="header-anchor" href="#_2-2、mysql的事务隔离级别"><span>2.2、MySQL的事务隔离级别</span></a></h3><p>出现上述数据一致性问题基本上都不是我们原因看到的，为了解决这些问题，SQL标准定义了四个事务隔离级别：①读未提交（Read UnCommitted）、②读已提交（Read Committed）、③可重复度（Repeatable Read）、④串行化（Serializable）</p><p>假设我们有一张学生表，下面示例以这张表为例：</p><div class="language-sql line-numbers-mode" data-highlighter="prismjs" data-ext="sql" data-title="sql"><pre><code><span class="line"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token identifier"><span class="token punctuation">\`</span>student<span class="token punctuation">\`</span></span> <span class="token punctuation">(</span></span>
<span class="line">  <span class="token identifier"><span class="token punctuation">\`</span>id<span class="token punctuation">\`</span></span> <span class="token keyword">int</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">AUTO_INCREMENT</span> <span class="token keyword">COMMENT</span> <span class="token string">&#39;主键id&#39;</span><span class="token punctuation">,</span></span>
<span class="line">  <span class="token identifier"><span class="token punctuation">\`</span>stu_no<span class="token punctuation">\`</span></span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span> <span class="token keyword">CHARACTER</span> <span class="token keyword">SET</span> utf8mb4 <span class="token keyword">COLLATE</span> utf8mb4_general_ci <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span> <span class="token keyword">COMMENT</span> <span class="token string">&#39;学号&#39;</span><span class="token punctuation">,</span></span>
<span class="line">  <span class="token identifier"><span class="token punctuation">\`</span>stu_name<span class="token punctuation">\`</span></span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">255</span><span class="token punctuation">)</span> <span class="token keyword">CHARACTER</span> <span class="token keyword">SET</span> utf8mb4 <span class="token keyword">COLLATE</span> utf8mb4_general_ci <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span> <span class="token keyword">COMMENT</span> <span class="token string">&#39;姓名&#39;</span><span class="token punctuation">,</span></span>
<span class="line">  <span class="token identifier"><span class="token punctuation">\`</span>birthday<span class="token punctuation">\`</span></span> <span class="token keyword">date</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span> <span class="token keyword">COMMENT</span> <span class="token string">&#39;出生日期&#39;</span><span class="token punctuation">,</span></span>
<span class="line">  <span class="token identifier"><span class="token punctuation">\`</span>address<span class="token punctuation">\`</span></span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">255</span><span class="token punctuation">)</span> <span class="token keyword">CHARACTER</span> <span class="token keyword">SET</span> utf8mb4 <span class="token keyword">COLLATE</span> utf8mb4_general_ci <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span> <span class="token keyword">COMMENT</span> <span class="token string">&#39;家庭住址&#39;</span><span class="token punctuation">,</span></span>
<span class="line">  <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span><span class="token identifier"><span class="token punctuation">\`</span>id<span class="token punctuation">\`</span></span><span class="token punctuation">)</span><span class="token punctuation">,</span></span>
<span class="line">  <span class="token keyword">UNIQUE</span> <span class="token keyword">KEY</span> <span class="token identifier"><span class="token punctuation">\`</span>idx_stu_no<span class="token punctuation">\`</span></span> <span class="token punctuation">(</span><span class="token identifier"><span class="token punctuation">\`</span>stu_no<span class="token punctuation">\`</span></span><span class="token punctuation">)</span> <span class="token keyword">USING</span> <span class="token keyword">BTREE</span></span>
<span class="line"><span class="token punctuation">)</span> <span class="token keyword">ENGINE</span><span class="token operator">=</span><span class="token keyword">InnoDB</span> <span class="token keyword">DEFAULT</span> <span class="token keyword">CHARSET</span><span class="token operator">=</span>utf8mb4 <span class="token keyword">COLLATE</span><span class="token operator">=</span>utf8mb4_general_ci <span class="token keyword">COMMENT</span><span class="token operator">=</span><span class="token string">&#39;学生表&#39;</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>表中有两条数据：</p><p><img src="http://blog.shengxiao.tech/images/image-20241112222330462.png" alt="image-20241112222330462"></p><ul><li>读未提交（RU）</li></ul><p>前面提到如果一个事务去读另一个事务未提交的数据，会出现脏读的问题，接下来模拟两个事务</p><p>事务A修改一条数据，但是不提交：</p><div class="language-sql line-numbers-mode" data-highlighter="prismjs" data-ext="sql" data-title="sql"><pre><code><span class="line"><span class="token comment">-- 关闭自动提交</span></span>
<span class="line"><span class="token keyword">set</span> <span class="token keyword">SESSION</span> autocommit<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token comment">-- 手动开启事务</span></span>
<span class="line"><span class="token keyword">BEGIN</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">UPDATE</span> student <span class="token keyword">set</span> stu_name <span class="token operator">=</span> <span class="token string">&#39;HanMeiMei007&#39;</span> <span class="token keyword">WHERE</span> id <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token comment">-- 修改不提交</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>执行：</p><p><img src="http://blog.shengxiao.tech/images/image-20241112223046987.png" alt="image-20241112223046987"></p><p>事务B在读未提交的隔离级别下去读</p><div class="language-sql line-numbers-mode" data-highlighter="prismjs" data-ext="sql" data-title="sql"><pre><code><span class="line"><span class="token comment">-- 将事务隔离级别设置为RU</span></span>
<span class="line"><span class="token keyword">SET</span> <span class="token keyword">SESSION</span> <span class="token keyword">TRANSACTION</span> <span class="token keyword">ISOLATION</span> <span class="token keyword">LEVEL</span> <span class="token keyword">READ</span> <span class="token keyword">UNCOMMITTED</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token comment">-- 查询</span></span>
<span class="line"><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> student<span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>执行，看能不能查到那条未提交的脏数据：</p><p><img src="http://blog.shengxiao.tech/images/image-20241112223150680.png" alt="image-20241112223150680"></p><p>其实默认的RR隔离级别下是看不到的：</p><p><img src="http://blog.shengxiao.tech/images/image-20241112223259453.png" alt="image-20241112223259453"></p><ul><li>读已提交（RC）</li></ul><p>为了解决脏读问题，我们可以将隔离级别设置为RC。那么在RC级别下是否真正解决了脏读的问题呢？我们来验证一下。</p><p>首先查询一下前面没提交的修改，看在RC下能读到吗</p><p><img src="http://blog.shengxiao.tech/images/image-20241112224200991.png" alt="image-20241112224200991"></p><blockquote><p>可以看出来没有读到</p></blockquote><p>接下来还是用两个事务，事务A仍然是去修改一条数据，但是和前面不同的是他修改完就提交了</p><div class="language-sql line-numbers-mode" data-highlighter="prismjs" data-ext="sql" data-title="sql"><pre><code><span class="line"><span class="token comment">-- 关闭自动提交</span></span>
<span class="line"><span class="token keyword">set</span> <span class="token keyword">SESSION</span> autocommit<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token comment">-- 手动开启事务</span></span>
<span class="line"><span class="token keyword">BEGIN</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">UPDATE</span> student <span class="token keyword">set</span> stu_name <span class="token operator">=</span> <span class="token string">&#39;HanMeiMei007&#39;</span> <span class="token keyword">WHERE</span> id <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">COMMIT</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token comment">-- 修改后提交</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>执行：</p><p><img src="http://blog.shengxiao.tech/images/image-20241112223737119.png" alt="image-20241112223737119"></p><p>接下来会话B模拟读已提交下的事务B去查询：</p><div class="language-sql line-numbers-mode" data-highlighter="prismjs" data-ext="sql" data-title="sql"><pre><code><span class="line"><span class="token comment">-- 将事务隔离级别设置为RU</span></span>
<span class="line"><span class="token keyword">SET</span> <span class="token keyword">SESSION</span> <span class="token keyword">TRANSACTION</span> <span class="token keyword">ISOLATION</span> <span class="token keyword">LEVEL</span> <span class="token keyword">READ</span> <span class="token keyword">COMMITTED</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token comment">-- 查询</span></span>
<span class="line"><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> student<span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>执行：</p><p><img src="http://blog.shengxiao.tech/images/image-20241112223808685.png" alt="image-20241112223808685"></p><blockquote><p>可以看到能够正常读取到已经提交的数据。</p></blockquote><p>所以可以看出来，RC隔离级别确实解决了脏读的问题</p><ul><li>可重复读（RR）</li></ul><p>都说可重复度解决了脏读、幻读、不可重复读的问题，同样也来验证一下</p><p>首先验证<strong>脏读</strong>问题，还是会话一修改不提交：</p><p><img src="http://blog.shengxiao.tech/images/image-20241112224928534.png" alt="image-20241112224928534"></p><p>会话二用RR级别去查一下，看能不能查到这条未提交的数据：</p><p><img src="http://blog.shengxiao.tech/images/image-20241112225049955.png" alt="image-20241112225049955"></p><p>可以看到没有查到</p><p>接下来验证一下<strong>不可重复读</strong>，会话一去查数据：</p><p><img src="http://blog.shengxiao.tech/images/image-20241112225259191.png" alt="image-20241112225259191"></p><p>会话二去修改这条数据：</p><p><img src="http://blog.shengxiao.tech/images/image-20241112225416365.png" alt="image-20241112225416365"></p><p>可以看到也修改成功了，那么会话一再去查结果会和第一次查询一样吗？</p><p><img src="http://blog.shengxiao.tech/images/image-20241112225537665.png" alt="image-20241112225537665"></p><blockquote><p>可以看到还是和原来的一样，也就是说解决了重复读的问题</p></blockquote><p>那么<strong>幻读</strong>真正的解决了吗？我们也来验证一下</p><p>会话一去查询学号大于1的学生：</p><div class="language-sql line-numbers-mode" data-highlighter="prismjs" data-ext="sql" data-title="sql"><pre><code><span class="line"><span class="token keyword">BEGIN</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> student <span class="token keyword">WHERE</span> id <span class="token operator">&gt;</span> <span class="token number">1</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p><img src="http://blog.shengxiao.tech/images/image-20241112230316951.png" alt="image-20241112230316951"></p><p>可以看到只有一条</p><p>接下来会话二插入一条记录：</p><div class="language-sql line-numbers-mode" data-highlighter="prismjs" data-ext="sql" data-title="sql"><pre><code><span class="line"><span class="token comment">-- 将事务隔离级别设置为RR</span></span>
<span class="line"><span class="token keyword">SET</span> <span class="token keyword">SESSION</span> <span class="token keyword">TRANSACTION</span> <span class="token keyword">ISOLATION</span> <span class="token keyword">LEVEL</span> <span class="token keyword">REPEATABLE</span> <span class="token keyword">READ</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token comment">-- 插入数据</span></span>
<span class="line"><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> student<span class="token punctuation">(</span>id<span class="token punctuation">,</span> stu_no<span class="token punctuation">,</span> stu_name<span class="token punctuation">,</span> birthday<span class="token punctuation">,</span> address<span class="token punctuation">)</span> <span class="token keyword">VALUES</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token string">&#39;103&#39;</span><span class="token punctuation">,</span> <span class="token string">&#39;David&#39;</span><span class="token punctuation">,</span> <span class="token string">&#39;2019-08-20&#39;</span><span class="token punctuation">,</span> <span class="token string">&#39;美国华尔街&#39;</span><span class="token punctuation">)</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><img src="http://blog.shengxiao.tech/images/image-20241112230058491.png" alt="image-20241112230058491"></p><blockquote><p>插入成功</p></blockquote><p>接下来回到会话一，再次查询：</p><p><img src="http://blog.shengxiao.tech/images/image-20241112230348375-1423829.png" alt="image-20241112230348375"></p><blockquote><p>可以看到还是只有一条</p></blockquote><p>但是如果开启一个新的事务却可以看到两条。所以在RR隔离级别下，确实解决了脏读、不可重复读和幻读问题</p><ul><li>串行化（Serializable）</li></ul><p>串行化是所有的事务都串行执行，当时所有问题都能够解决，这里不去验证了。</p><p>但是随着隔级别从上到下解决的问题越多，随之而来的自然是性能的牺牲。就像我们在架构设计的时候经常考虑的CAP理论一样，性能和成本只能尽量去平衡，鱼和熊掌不可兼得。好在对于数据一致性的这四个问题，除了脏读问题不能接受之外，其它几个问题在特定的业务场景下并不是完全不可接受，总的来说还是要结合自己的业务场景去选择。</p><p>对于InnoDB来说，默认的RR隔离级别基本上能满足我们绝大部分场景</p><hr><p><img src="http://blog.shengxiao.tech/images/subscribe1.png" alt="扫码关注"></p>`,97))])}const g=p(r,[["render",k]]),h=JSON.parse('{"path":"/series/db/mysql/05MySQLshiwutexingheshiwugelijibie.html","title":"5、MySQL事务特性和事务隔离级别","lang":"en-US","frontmatter":{"title":"5、MySQL事务特性和事务隔离级别","date":"2024-11-14T00:00:00.000Z","categories":["mysql","数据库"],"tags":["mysql","数据库"]},"headers":[{"level":2,"title":"1、MySQL的事务特性","slug":"_1、mysql的事务特性","link":"#_1、mysql的事务特性","children":[{"level":3,"title":"1.1、原子性","slug":"_1-1、原子性","link":"#_1-1、原子性","children":[]},{"level":3,"title":"1.2、一致性","slug":"_1-2、一致性","link":"#_1-2、一致性","children":[]},{"level":3,"title":"1.3、隔离性","slug":"_1-3、隔离性","link":"#_1-3、隔离性","children":[]},{"level":3,"title":"1.4、持久性","slug":"_1-4、持久性","link":"#_1-4、持久性","children":[]}]},{"level":2,"title":"2、事务的隔离级别","slug":"_2、事务的隔离级别","link":"#_2、事务的隔离级别","children":[{"level":3,"title":"2.1、数据一致性问题","slug":"_2-1、数据一致性问题","link":"#_2-1、数据一致性问题","children":[]},{"level":3,"title":"2.2、MySQL的事务隔离级别","slug":"_2-2、mysql的事务隔离级别","link":"#_2-2、mysql的事务隔离级别","children":[]}]}],"git":{"createdTime":1765551376000,"updatedTime":1765551376000,"contributors":[{"name":"qknavy","email":"qknavy@aliyun.com","commits":1}]},"filePathRelative":"series/db/mysql/05MySQL事务特性和事务隔离级别.md"}');export{g as comp,h as data};
