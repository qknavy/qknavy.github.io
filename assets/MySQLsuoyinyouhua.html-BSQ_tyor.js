import{_ as o,c as l,b as p,a as n,d as a,e as t,r as i,o as c}from"./app-BG-FaH7C.js";const r={},d={href:"https://dev.mysql.com/doc/refman/8.0/en/explain-output.html",target:"_blank",rel:"noopener noreferrer"},u={href:"https://dev.mysql.com/doc/refman/8.0/en/explain-output.html#explain-join-types",target:"_blank",rel:"noopener noreferrer"},k={href:"https://dev.mysql.com/doc/refman/8.0/en/explain-output.html#explain-extra-information",target:"_blank",rel:"noopener noreferrer"};function h(m,s){const e=i("ExternalLinkIcon");return c(),l("div",null,[s[5]||(s[5]=p('<div class="custom-container info"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="9"></circle><path d="M12 8h.01"></path><path d="M11 12h1v4h1"></path></g></svg><p class="custom-container-title">INFO</p><p>从索引带来的效果以及索引执行的流程分析MySQL可能优化的环节，简单介绍如何取查看SQL的执行计划</p></div><h2 id="_1、索引的效果" tabindex="-1"><a class="header-anchor" href="#_1、索引的效果"><span>1、索引的效果</span></a></h2><p>有一个优惠券表<code>coupon_code</code>，表结构如下：</p><div class="language-sql line-numbers-mode" data-highlighter="prismjs" data-ext="sql" data-title="sql"><pre><code><span class="line"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token identifier"><span class="token punctuation">`</span>coupon_code<span class="token punctuation">`</span></span> <span class="token punctuation">(</span></span>\n<span class="line">  <span class="token identifier"><span class="token punctuation">`</span>id<span class="token punctuation">`</span></span> <span class="token keyword">int</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">AUTO_INCREMENT</span><span class="token punctuation">,</span></span>\n<span class="line">  <span class="token identifier"><span class="token punctuation">`</span>code<span class="token punctuation">`</span></span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">36</span><span class="token punctuation">)</span> <span class="token keyword">COLLATE</span> utf8mb4_general_ci <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">COMMENT</span> <span class="token string">&#39;优惠券码&#39;</span><span class="token punctuation">,</span></span>\n<span class="line">  <span class="token identifier"><span class="token punctuation">`</span>type<span class="token punctuation">`</span></span> <span class="token keyword">int</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span> <span class="token keyword">COMMENT</span> <span class="token string">&#39;优惠券类型&#39;</span><span class="token punctuation">,</span></span>\n<span class="line">  <span class="token identifier"><span class="token punctuation">`</span>status<span class="token punctuation">`</span></span> <span class="token keyword">int</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span> <span class="token keyword">COMMENT</span> <span class="token string">&#39;使用状态：0-未使用，1-已使用&#39;</span><span class="token punctuation">,</span></span>\n<span class="line">  <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span><span class="token identifier"><span class="token punctuation">`</span>id<span class="token punctuation">`</span></span><span class="token punctuation">)</span></span>\n<span class="line"><span class="token punctuation">)</span> <span class="token keyword">ENGINE</span><span class="token operator">=</span><span class="token keyword">InnoDB</span> <span class="token keyword">DEFAULT</span> <span class="token keyword">CHARSET</span><span class="token operator">=</span>utf8mb4 <span class="token keyword">COLLATE</span><span class="token operator">=</span>utf8mb4_general_ci <span class="token keyword">COMMENT</span><span class="token operator">=</span><span class="token string">&#39;优惠券&#39;</span><span class="token punctuation">;</span></span>\n<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>表里有1000050条数据</p><p><img src="http://blog.shengxiao.tech/images/image-20241111215603842.png" alt="image-20241111215603842"></p><p>现在我要查询某个优惠券码，使用SQL查询：</p><div class="language-sql line-numbers-mode" data-highlighter="prismjs" data-ext="sql" data-title="sql"><pre><code><span class="line"><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> coupon_code <span class="token keyword">WHERE</span> code <span class="token operator">=</span> <span class="token string">&#39;1855885657679990868&#39;</span><span class="token punctuation">;</span></span>\n<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>可以看到查询时间：</p><img src="http://blog.shengxiao.tech/images/image-20241111172214820.png" alt="image-20241111172214820" style="zoom:100%;"><p>单查询383ms的查询速度还是比较慢的。为了优化查询，我们在<code>name</code>这一列添加一个索引：</p><div class="language-sql line-numbers-mode" data-highlighter="prismjs" data-ext="sql" data-title="sql"><pre><code><span class="line"><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> <span class="token identifier"><span class="token punctuation">`</span>test001<span class="token punctuation">`</span></span><span class="token punctuation">.</span><span class="token identifier"><span class="token punctuation">`</span>coupon_code<span class="token punctuation">`</span></span> <span class="token keyword">ADD</span> <span class="token keyword">INDEX</span> <span class="token identifier"><span class="token punctuation">`</span>idx_code<span class="token punctuation">`</span></span><span class="token punctuation">(</span><span class="token identifier"><span class="token punctuation">`</span>code<span class="token punctuation">`</span></span><span class="token punctuation">)</span> <span class="token keyword">USING</span> <span class="token keyword">BTREE</span><span class="token punctuation">;</span></span>\n<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>接下来就是见证奇迹的时刻：</p><div class="language-sql line-numbers-mode" data-highlighter="prismjs" data-ext="sql" data-title="sql"><pre><code><span class="line"><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> coupon_code <span class="token keyword">WHERE</span> code <span class="token operator">=</span> <span class="token string">&#39;1855885657679990868&#39;</span><span class="token punctuation">;</span></span>\n<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><img src="http://blog.shengxiao.tech/images/image-20241111172659517.png" alt="image-20241111172659517" style="zoom:100%;"><p>可以看到查询时间已经到1ms了，这就是索引的效果，索引建立得当确实可以很大程度上提升查询性能</p><h2 id="_2、索引的过程" tabindex="-1"><a class="header-anchor" href="#_2、索引的过程"><span>2、索引的过程</span></a></h2><p>前面的文章也介绍了通过索引去查询数据的流程，大体就是：</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text" data-title="text"><pre><code><span class="line">[二级索引树] --&gt; [二级索引树的叶子节点找到ID] --&gt; [回表，到主键索引树检索] --&gt; [找到对应叶子节点上的目标数据]</span>\n<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>后面的优化思路就是按照这个流程来贯彻的</p><h2 id="_3、索引优化" tabindex="-1"><a class="header-anchor" href="#_3、索引优化"><span>3、索引优化</span></a></h2><h3 id="_3-1、主键索引" tabindex="-1"><a class="header-anchor" href="#_3-1、主键索引"><span>3.1、主键索引</span></a></h3><p>由于数据就保存在主键索引中，所以通常情况下，走主键索引肯定比走二级索引要快，因为少了一个回表的过程。</p><p>利用主键索引来进行SQL优化的场景常见的是大表的检索，比如一个表有一千万条数据，如果要从第500万条查询接下来的10条，这个时候如果要用MySQL的<code>limit</code>，那查询依然会很慢，因为MySQL会首先对前500万条数据排序后再取10条，然后其它的数据就丢弃了。可能“丢西瓜捡芝麻”在这里用来比喻并不是很恰当，但费劲巴拉才拿到这10条数据成本确实有点大。</p><p>比如还是上面的那个100万的表，从80万取10条数据为例：</p><img src="http://blog.shengxiao.tech/images/image-20241111214655302.png" alt="image-20241111214655302" style="zoom:100%;"><p>可以看到这就用了293ms了，明显速度还是比较慢的</p><p>像这个场景有什么好的优化办法呢？主要有两种方案：</p><ul><li>按照ID截取</li></ul><p>这种方式主要针对主键是数值类型（特别是连续自增）的场景。因为像InnoDB存储引擎，主键索引肯定是存在的，而且是已经排好序的，这个时候我们可以这么去查：</p><div class="language-sql line-numbers-mode" data-highlighter="prismjs" data-ext="sql" data-title="sql"><pre><code><span class="line"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> coupon_code <span class="token keyword">where</span> id <span class="token operator">&gt;</span> <span class="token number">800000</span> <span class="token keyword">ORDER</span> <span class="token keyword">BY</span> id <span class="token keyword">limit</span> <span class="token number">10</span></span>\n<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>看结果：</p><img src="http://blog.shengxiao.tech/images/image-20241111214807886.png" alt="image-20241111214807886" style="zoom:100%;"><p>这就是差距。程序在实现分页的时候只需要将每次查询的最大ID传回来就可以知道数据查询到哪里了</p><ul><li>子查询方式</li></ul><p>除了按照ID截取的这种方式，还可以通过子查询的方式，比如：</p><div class="language-sql line-numbers-mode" data-highlighter="prismjs" data-ext="sql" data-title="sql"><pre><code><span class="line"><span class="token keyword">SELECT</span> t1<span class="token punctuation">.</span><span class="token operator">*</span> <span class="token keyword">FROM</span> coupon_code t1 </span>\n<span class="line"><span class="token keyword">INNER</span> <span class="token keyword">JOIN</span> <span class="token punctuation">(</span><span class="token keyword">SELECT</span> id <span class="token keyword">FROM</span> coupon_code <span class="token keyword">ORDER</span> <span class="token keyword">BY</span> id <span class="token keyword">LIMIT</span> <span class="token number">800000</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">)</span> t2</span>\n<span class="line"><span class="token keyword">ON</span> t1<span class="token punctuation">.</span>id <span class="token operator">=</span> t2<span class="token punctuation">.</span>id</span>\n<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>查询结果：</p><p><img src="http://blog.shengxiao.tech/images/image-20241111215312410.png" alt="image-20241111215312410"></p><p>可以看到相对于直接<code>limit</code>查询是有一定的提升的，虽在在这个数据量上对比还不是特别明显，但也有293ms降到了172ms</p><p>说到主键，这里插一个题外话，比如有人问你：count(*)、count(1)、count(id)、和count(xxx)这几个有什么区别？</p><p>这里需要了解一下count的逻辑了，它是查询到值就加1，那么这几个的区别就不言而喻了：</p><blockquote><p><code>*</code> 肯定不会为空，因为一行记录不可能所有的列都是空，至少有一列有值</p><p><code>1</code>1肯定不是空</p><p><code>id</code>id肯定也不会是空</p><p><code>xxx</code>这可就不一定了，还是需要判断一下</p><p>你猜哪个性能会更好一点呢？</p></blockquote><p>这里不得不提一句为什么MySQL建议大家使用自增ID作为InnoDB的主键，它的优势除了索引键所占的空间比较小之外也体现在这里，当然自增主键在插入数据的时候对索引树的维护上也有一定的优势，因为它只需要添加节点就行了，而如果是非自增的主键你还得对key进行分裂合并。总之这些点点滴滴都是会影响到SQL查询性能的点</p><h3 id="_3-2、索引覆盖" tabindex="-1"><a class="header-anchor" href="#_3-2、索引覆盖"><span>3.2、索引覆盖</span></a></h3><p>在我们的业务开发中，不可能都是按照主键索引来查的，更多的时候需要借助二级索引，不管是单列的二级索引还是联合索引。前面我们在体验索引的效果的时候就通过在<code>code</code>字段上创建了一个二级索引来感受到了索引的好处。</p><p>但行数据总归还是在主键索引上，每次通过二级索引的查询还是需要经历一次回表的过程，那能不能省去这个环节呢，如果能省去回表这个环节的话那肯定性能会有提升。</p><p>答案当然是肯定的，但也是有条件的</p><p>还是拿上面优惠券表为例，在<code>code</code>列的索引树上，我们经过分析顶破天也只有索引键以及对应叶子节点上的id信息。所以，如果我们要拿到code和id之外的信息就必须经过一次回表过程。</p><p>换句话说，如果我们只需要code和id信息，那么就可以不用回表啦，之前也提到过，这就是<strong>索引覆盖</strong></p><p>讲到这里其实也就可以理解为什么有人建议我们在查询的时候不要统统<code>select * </code>，而是需要什么字段就<code>select</code>什么字段了，因为这样的话是有可能命中索引键从而走索引覆盖不用回表，提升了查询性能优化的可能性</p><h3 id="_3-3、索引下推" tabindex="-1"><a class="header-anchor" href="#_3-3、索引下推"><span>3.3、索引下推</span></a></h3><p>还是以上面优惠券这个表为例，如果我们创建了这样一个联合索引：</p><div class="language-sql line-numbers-mode" data-highlighter="prismjs" data-ext="sql" data-title="sql"><pre><code><span class="line"><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> <span class="token identifier"><span class="token punctuation">`</span>test001<span class="token punctuation">`</span></span><span class="token punctuation">.</span><span class="token identifier"><span class="token punctuation">`</span>coupon_code<span class="token punctuation">`</span></span> <span class="token keyword">ADD</span> <span class="token keyword">INDEX</span> <span class="token identifier"><span class="token punctuation">`</span>idx_code_type<span class="token punctuation">`</span></span><span class="token punctuation">(</span><span class="token identifier"><span class="token punctuation">`</span>code<span class="token punctuation">`</span></span><span class="token punctuation">,</span> <span class="token identifier"><span class="token punctuation">`</span>type<span class="token punctuation">`</span></span><span class="token punctuation">)</span> <span class="token keyword">USING</span> <span class="token keyword">BTREE</span><span class="token punctuation">;</span></span>\n<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>假如有以下查询，请问这个联合索引会生效吗？</p><div class="language-sql line-numbers-mode" data-highlighter="prismjs" data-ext="sql" data-title="sql"><pre><code><span class="line"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> coupon_code <span class="token keyword">where</span> <span class="token keyword">type</span> <span class="token operator">=</span> <span class="token number">3</span> <span class="token operator">and</span> code <span class="token operator">like</span> <span class="token string">&#39;%612511&#39;</span></span>\n<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>因为code列是<code>%</code>前缀，明显不会生效，但是存储引擎会扫描整颗二级索引索引树，大概流程如下图所示：</p><p><img src="http://blog.shengxiao.tech/images/image-20241111222507135.png" alt="image-20241111222507135"></p><blockquote><p>① 客户端提交SQL到server</p><p>② server去调存储引擎</p><p>③ 存储引擎首先走二级索引用索引key去检索，由于code是<code>%</code>前缀，所以会扫描整颗索引树，并将type=3的id都找出来</p><p>④ 从二级索引中拿到对应的id之后回表，从主键索引中拿到具体的数据行，并返回给server层</p><p>⑤ server层会用where 条件去过去过滤，拿到最终满足条件的数据，并返回给客户端</p></blockquote><p>在我们上面“优惠券”这个例子中，type是固定的几个值，这样一来通过type=3查到的id就会非常多，回表后拿到的行数据也就会非常多。这么多的数据在存储引擎和server层进行交互，势必会消耗一定的时间。</p><p>从上面的图也可以看出，server拿到的也并不都是自己想要的数据，它想要的只是code以后缀<code>612511</code>结尾的数据，这突然一下子把这么多数据怼过来需要消耗性能不说，过后server还得去再一次过滤。这个环节有没有可以优化的点呢？</p><p>当然是有的。</p><p>前面有一个关键环节就是扫描整个二级索引，既然后面也需要server去挨个过滤，而这棵索引树也包含了所有的code，为什么不能在这个时候就将以<code>612511</code>结尾的code并且type为3的挑出来呢？</p><p>这个技术就叫<strong>索引下推</strong></p><p>索引下推只对InnoDB和MyISAM存储引擎有效，默认情况下这个功能就是开启的，也可以手动关闭。开启索引下推后上面的流程就变成如下图所示了：</p><p><img src="http://blog.shengxiao.tech/images/image-20241111230356839.png" alt="image-20241111230356839"></p><blockquote><p>这里的关键步骤就是在二级索引的扫描的时候，先就把以<code>612511</code>结尾的择出来了，这样回表的数据也少了，引擎层返回给server层的数据也少了，server层也不用再用这个<code>code like &#39;%612511&#39;</code>去过滤了，一举多得。伴随的性能自然能得到提升了。</p></blockquote><h3 id="_3-4、如何选择索引" tabindex="-1"><a class="header-anchor" href="#_3-4、如何选择索引"><span>3.4、如何选择索引</span></a></h3><ul><li><p>索引不是越多越好</p><blockquote><p>① 因为索引是有大小限制的，官网介绍了InnoDB中一个表最多有一千多列，最多有64个二级索引。如果索引过多，会占用过多的内存空间</p><p>② 每个索引都会对应一棵索引树，每次数据变更相应的索引树也需要同步进行变更，所谓牵一发而动全身，过多的索引维护起来会特别麻烦</p></blockquote></li><li><p>尽量控制索引键的长度</p><blockquote><p>索引键的长度会影响一个页中能保存的key的数量，而数量越多，索引树的深度越低，检索的时候I/O的次数就会越少，性能相对会越好。</p><p>从这个角度来说，因为像InnoDB的主键索引树也会保存行数据，如果一个行特别大，比如有特别大的列的时候，能够放的行数据就会越少，所以如果有特别大的列的话可以考虑拆分出去</p></blockquote></li><li><p>离散性不是很好的列不建议加索引</p><blockquote><p>像上面“优惠券”的示例中的type列，总共也就那么几个值，即使按照type去检索也和全表扫描差不多嘞，还得单独维护一棵索引树，有点不划算</p></blockquote></li><li><p>尽量采用联合索引</p><blockquote><p>联合索引只需要维护一棵索引树就可以在多个列上进行索引，只要结合我们的业务场景索引建立得当</p></blockquote></li></ul><h3 id="_3-5、索引失效的场景" tabindex="-1"><a class="header-anchor" href="#_3-5、索引失效的场景"><span>3.5、索引失效的场景</span></a></h3><p>索引失效的场景有离散型不行的列上的索引、不满足最左匹配（如上面的%前缀）。对于联合索引的查询哪些列可以走索引可以参考最左匹配原则，总的来说就是从哪一列开始，后续的列数据是无序的，如果后面是无序了，那它肯定不走索引了</p><h2 id="_4、执行计划" tabindex="-1"><a class="header-anchor" href="#_4、执行计划"><span>4、执行计划</span></a></h2><p>如果要做SQL优化，怎么可能不看执行计划呢，所以接下来介绍一下执行计划都需要关注哪些点</p><h3 id="_4-1、如何查看执行计划" tabindex="-1"><a class="header-anchor" href="#_4-1、如何查看执行计划"><span>4.1、如何查看执行计划</span></a></h3><p>查看执行计划非常简单，直接执行<code>explain</code>就行，如</p><div class="language-sql line-numbers-mode" data-highlighter="prismjs" data-ext="sql" data-title="sql"><pre><code><span class="line"><span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> coupon_code <span class="token keyword">where</span> id <span class="token operator">&gt;</span> <span class="token number">800000</span> <span class="token keyword">ORDER</span> <span class="token keyword">BY</span> id <span class="token keyword">limit</span> <span class="token number">10</span></span>\n<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p><img src="http://blog.shengxiao.tech/images/image-20241111233243115.png" alt="image-20241111233243115"></p><h3 id="_4-2、执行计划需要关注点" tabindex="-1"><a class="header-anchor" href="#_4-2、执行计划需要关注点"><span>4.2、执行计划需要关注点</span></a></h3>',78)),n("p",null,[n("a",d,[s[0]||(s[0]=a("参考链接",-1)),t(e)])]),s[6]||(s[6]=p('<h4 id="_4-2-1、select-type" tabindex="-1"><a class="header-anchor" href="#_4-2-1、select-type"><span>4.2.1、select_type</span></a></h4><p><code>select_type</code>可以看出查询类型，比如是简单的单表查询（simple）呢，还是带有子查询（subquery），取值范围如下：</p><p><img src="http://blog.shengxiao.tech/images/image-20241111234522749.png" alt="image-20241111234522749"></p><h4 id="_4-2-2、table" tabindex="-1"><a class="header-anchor" href="#_4-2-2、table"><span>4.2.2、table</span></a></h4><p>有联合查询或者子查询的情况</p><h4 id="_4-2-3、type" tabindex="-1"><a class="header-anchor" href="#_4-2-3、type"><span>4.2.3、type</span></a></h4>',6)),n("p",null,[s[2]||(s[2]=a("性能从好到坏的取值：",-1)),n("a",u,[s[1]||(s[1]=a("参考链接",-1)),t(e)])]),s[7]||(s[7]=p('<ul><li>system：一个表只有一行记录</li><li>const：最多只有一个匹配行</li><li>eq_ref：主键索引或者唯一索引，一般用<code>=</code>号</li><li>ref：主键索引或者唯一索引，一般用<code>=</code>号或者&lt;==&gt;，和eq_ref的区别就是一个针对关联表一个针对被关联的关系</li><li>fulltext：全文索引</li><li>ref_or_null：和ref不同在于会额外搜索包含null值的行，通常用于解决子查询</li><li>index_merge：输出行中的键列包含所使用的索引列表，key_len包含所使用索引的最长键部分列表</li><li>unique_subquery：IN的主键子查询</li><li>index_subquery：IN的普通列子查询</li><li>range：范围查询</li><li>index：只是扫描了索引树，Extra列对应<code>Using Index</code></li><li>all：全表扫描</li></ul><h4 id="_4-2-4、possible-keys" tabindex="-1"><a class="header-anchor" href="#_4-2-4、possible-keys"><span>4.2.4、possible_keys</span></a></h4><p>可能用到的索引</p><h4 id="_4-2-5、key" tabindex="-1"><a class="header-anchor" href="#_4-2-5、key"><span>4.2.5、key</span></a></h4><p>推测SQL走的索引，如果有值，可以关注一下<code>key_len</code>这列的值</p><h4 id="_4-2-6、ref" tabindex="-1"><a class="header-anchor" href="#_4-2-6、ref"><span>4.2.6、ref</span></a></h4><p>将哪些列或常量与键列中指定的索引进行比较</p><h4 id="_4-2-7、rows" tabindex="-1"><a class="header-anchor" href="#_4-2-7、rows"><span>4.2.7、rows</span></a></h4><p>推测的要扫描的数据行数，不准</p><h4 id="_4-2-8、filtered" tabindex="-1"><a class="header-anchor" href="#_4-2-8、filtered"><span>4.2.8、filtered</span></a></h4><p>表示按表条件筛选的表行的估计百分比</p><h4 id="_4-2-9、extra" tabindex="-1"><a class="header-anchor" href="#_4-2-9、extra"><span>4.2.9、Extra</span></a></h4>',12)),n("p",null,[s[4]||(s[4]=a("MySQL如何解析查询的其他信息，",-1)),n("a",k,[s[3]||(s[3]=a("参考链接",-1)),t(e)])]),s[8]||(s[8]=n("hr",null,null,-1)),s[9]||(s[9]=n("p",null,[n("img",{src:"http://blog.shengxiao.tech/images/subscribe1.png",alt:"扫码关注，一起学习吧"})],-1))])}const y=o(r,[["render",h]]),b=JSON.parse('{"path":"/series/db/mysql/MySQLsuoyinyouhua.html","title":"4、MySQL索引优化","lang":"en-US","frontmatter":{"title":"4、MySQL索引优化","date":"2024-11-12T00:00:00.000Z","categories":["mysql","数据库"],"tags":["mysql","数据库"]},"headers":[{"level":2,"title":"1、索引的效果","slug":"_1、索引的效果","link":"#_1、索引的效果","children":[]},{"level":2,"title":"2、索引的过程","slug":"_2、索引的过程","link":"#_2、索引的过程","children":[]},{"level":2,"title":"3、索引优化","slug":"_3、索引优化","link":"#_3、索引优化","children":[{"level":3,"title":"3.1、主键索引","slug":"_3-1、主键索引","link":"#_3-1、主键索引","children":[]},{"level":3,"title":"3.2、索引覆盖","slug":"_3-2、索引覆盖","link":"#_3-2、索引覆盖","children":[]},{"level":3,"title":"3.3、索引下推","slug":"_3-3、索引下推","link":"#_3-3、索引下推","children":[]},{"level":3,"title":"3.4、如何选择索引","slug":"_3-4、如何选择索引","link":"#_3-4、如何选择索引","children":[]},{"level":3,"title":"3.5、索引失效的场景","slug":"_3-5、索引失效的场景","link":"#_3-5、索引失效的场景","children":[]}]},{"level":2,"title":"4、执行计划","slug":"_4、执行计划","link":"#_4、执行计划","children":[{"level":3,"title":"4.1、如何查看执行计划","slug":"_4-1、如何查看执行计划","link":"#_4-1、如何查看执行计划","children":[]},{"level":3,"title":"4.2、执行计划需要关注点","slug":"_4-2、执行计划需要关注点","link":"#_4-2、执行计划需要关注点","children":[]}]}],"git":{"createdTime":null,"updatedTime":null,"contributors":[]},"filePathRelative":"series/db/mysql/MySQL索引优化.md"}');export{y as comp,b as data};
